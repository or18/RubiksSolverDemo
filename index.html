<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <title>Rubik's Cube Solver</title>
    <meta name="description"
        content="Fast solver for Rubik's Cube cross, XCross, EOCross, free pair, pseudo F2L, and last layer. ">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MXJH30352W"></script>
    <script async src="src/min2phase.js/min2phase.js"></script>
    <script async src="src/functions/list.js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-MXJH30352W');
    </script>
    <style>
        header {
            padding: 2px;
            text-align: center;
            cursor: pointer;
            background-color: #121212;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
            background-color: #121212;
        }

        h1 {
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
            color: #ffffff;
        }

        h2,
        label {
            font-family: Arial, sans-serif;
            font-size: 20px;
            text-align: left;
            color: #ffffff;
        }

        textarea {
            font-family: Arial, sans-serif;
            width: 100%;
            max-width: 700px;
            height: 200px;
            font-size: 20px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #41417f;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
        }

        input {
            font-family: Arial, sans-serif;
            width: 100%;
            max-width: 100px;
            height: 40px;
            font-size: 20px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #41417f;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
        }

        select {
            font-family: Arial, sans-serif;
            max-width: 200px;
            font-size: 20px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ffffff;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
            cursor: pointer;
        }

        .button {
            font-family: Arial, sans-serif;
            width: 100%;
            font-size: 20px;
            padding: 10px;
            background-color: #56567c;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 4px;
        }

        .medium {
            max-width: 90px;
        }

        .small {
            max-width: 40px;
        }

        button:hover {
            background-color: #4a4a6d;
        }

        summary {
            box-sizing: border-box;
            display: block;
            font-family: Arial, sans-serif;
            padding: 10px;
            font-size: 20px;
            color: #ffffff;
            cursor: pointer;
        }

        details {
            border: 1px solid #41417f;
            border-radius: 8px;
            padding: 5px;
            margin: 10px 0;
            width: 100%;
        }

        .analyzer_result {
            color: #ffffff;

        }

        .panalyzer_result {
            color: #ffffff;
        }

        .pair_analyzer_result {
            color: #ffffff;
        }

        .pair_panalyzer_result {
            color: #ffffff;
        }

        .eo_analyzer_result {
            color: #ffffff;
        }

        table,
        ptable,
        pair_table,
        pair_ptable,
        eo_table {
            width: 100%;
            max-height: 400px;
            overflow-x: auto;
            display: block;
        }

        th,
        td {
            text-align: left;
            white-space: nowrap;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 20px;
            min-width: 40px;
            min-height: 40px;
        }

        td {
            cursor: pointer;
        }

        .table-res_table_wrapper {
            max-height: 400px;
            overflow: auto;
        }

        #move_available_table_wrapper {
            overflow-x: auto;
            max-width: 100%;
            position: relative;
        }

        #move_available_table {
            max-height: 400px;
            overflow: auto;
        }

        #move_available_table tbody th {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            background: #1e1e1e;
            z-index: 1;
        }

        #move_available_table thead th:first-child {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            background: #1e1e1e;
            z-index: 2;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #1e1e1e;
            z-index: 2;
        }

        .hidden {
            display: none;
        }

        .hidden_small {
            display: none;
        }

        a,
        pre {
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 20px;
        }

        twisty-player {
            margin: 0;
            width: 100%;
            max-width: 600px;
        }

        .custom-checkbox {
            display: none;
        }

        .custom-checkbox+label {
            position: relative;
            padding-left: 33px;
            cursor: pointer;
            font-size: 20px;
            color: #ffffff;
            user-select: none;
        }

        .custom-checkbox+label:before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #41417f;
            background-color: #1e1e1e;
        }

        .custom-checkbox:checked+label:before {
            background-color: #41417f;
            border-color: #41417f;
        }

        .custom-checkbox:checked+label:after {
            content: '';
            position: absolute;
            left: 9px;
            top: 5px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        fieldset {
            border: 1px solid #121212;
            border-radius: 4px;
            padding: 10px;
            background-color: #121212;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 50;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal-panel {
            background-color: #1e1e1e;
            border: 1px solid #41417f;
            border-radius: 4px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 42rem;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #41417f;
        }

        .modal-header h2 {
            font-size: 20px;
            font-weight: bold;
            margin: 0;
        }

        .modal-header .header-left-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .modal-header .button-group {
            display: flex;
            align-items: center;
        }

        .modal-header .copy-btn {
            padding: 5px 15px;
            font-size: 18px;
        }

        .modal-header .close-btn {
            font-size: 2.5rem;
            line-height: 1;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            padding: 0 10px;
        }

        .modal-content {
            padding: 1.5rem;
            overflow-y: auto;
        }

        .modal-content pre {
            font-family: Arial, sans-serif;
            white-space: pre-wrap;
            font-size: 18px;
            color: #e0e0e0;
        }

        body.modal-open {
            overflow: hidden;
        }

        .checkbox-table {
            width: 100%;
            max-width: 410px;
            margin-top: 10px;
            border-collapse: collapse;
            border: 1px solid #41417f;
        }

        .checkbox-table td {
            border: 1px solid #41417f;
            padding: 10px;
            background-color: #1e1e1e;
            text-align: center;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: flex-start;
            gap: 20px;
            padding: 15px;
            background-color: #1e1e1e;
            border-radius: 8px;
            border: 1px solid #41417f;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-button,
        .action-button {
            font-size: 16px;
            padding: 8px 16px;
            background-color: #56567c;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mode-button.active {
            background-color: #8a8ac8;
            box-shadow: 0 0 10px #8a8ac8;
        }

        .action-button:hover,
        .mode-button:hover {
            background-color: #7171a8;
        }

        .color-setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-setting-row label {
            width: 25px;
            text-align: right;
            font-weight: bold;
        }

        .color-selector {
            font-size: 18px;
            padding: 5px;
            background-color: #1e1e1e;
            color: #ffffff;
            border: 1px solid #41417f;
            border-radius: 4px;
            cursor: pointer;
        }

        .custom-color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            border: none;
            background: none;
            cursor: pointer;
            vertical-align: middle;
        }

        .hidden {
            display: none;
        }

        .cube-scroll-container {
            width: 100%;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .unfolded-cube {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 540px;
            height: 405px;
            margin: 0;
        }

        .face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            padding: 4px;
            background-color: #111;
            border-radius: 5px;
        }

        #face-U {
            grid-area: 1 / 4 / 4 / 7;
        }

        #face-L {
            grid-area: 4 / 1 / 7 / 4;
        }

        #face-F {
            grid-area: 4 / 4 / 7 / 7;
        }

        #face-R {
            grid-area: 4 / 7 / 7 / 10;
        }

        #face-B {
            grid-area: 4 / 10 / 7 / 13;
        }

        #face-D {
            grid-area: 7 / 4 / 10 / 7;
        }

        .sticker {
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .sticker.selected {
            transform: scale(0.9);
            box-shadow: 0 0 15px 3px yellow;
            border: 2px solid yellow;
        }

        .move-count-input {
            font-family: Arial, sans-serif;
            width: 60px;
            max-width: 100px;
            height: 40px;
            font-size: 20px;
            border: 1px solid #41417f;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
            text-align: center;
            margin: 0;
        }

        .move-count-input:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>

<body>
    <header id="header">
        <h1>Rubik's Cube Solver</h1>
    </header>
    <h2>This is solver for Rubik's cube cross, XCross, XXCross, XXXCross, XXXXCross, free pair, last layer. Pseudo
        XCross and free pair solver also available. EOCross and XEOCross
        solver also available.
    </h2>
    <h2>Update: The solver and trainers work offline after you install the web app from your browser.
    </h2>
    <div id="hamburger-menu-container">
        <button id="hamburger-menu-btn" aria-label="Open menu"
            style="background:none;border:none;cursor:pointer;font-size:2.2rem;position:absolute;top:10px;left:10px;z-index:1000;color:#fff;">
            &#9776;
        </button>
        <nav id="hamburger-menu" class="hidden"
            style="position:absolute;top:50px;left:10px;background:#1e1e1e;border:1px solid #41417f;border-radius:8px;box-shadow:0 4px 16px #000a;padding:16px;min-width:220px;z-index:1001;">
            <a href="https://github.com/or18/RubiksSolverDemo" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">Source</a>
            <a href="index.html" style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;">Main Solver</a>
            <a href="2x2x2.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">2x2x2 Solver</a>
            <a href="documentation.html" style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;"
                translate="no">Documentation</a>
            <span style="font-weight:bold;margin-top:12px;display:block;color:#fff;">Trainers:</span>
            <a href="cross_trainer.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">Cross</a>
            <a href="xcross_trainer.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">XCross</a>
            <a href="pairing_trainer.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">Free Pair</a>
            <a href="pseudo_xcross_trainer.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">Pseudo XCross</a>
            <a href="pseudo_pairing_trainer.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">Pseudo Free
                Pair</a>
            <a href="eocross_trainer.html" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">EOCross</a>
            <span style="font-weight:bold;margin-top:12px;display:block;color:#fff;">External tools:</span>
            <a href="https://trangium.github.io/MovecountCoefficient/" target="_blank" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">MCC by
                trangium</a>
            <a href="https://speedcubedb.com/a/3x3/" target="_blank" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;"
                translate="no">speedcubedb.com</a>
            <a href="https://cstimer.net/" target="_blank" rel="noopener noreferrer"
                style="display:block;margin-bottom:8px;white-space:nowrap;color:#fff;" translate="no">cstimer.net</a>
        </nav>
    </div>
    <script>
        const hamburgerBtn = document.getElementById('hamburger-menu-btn');
        const hamburgerMenu = document.getElementById('hamburger-menu');
        document.addEventListener('click', function (e) {
            if (hamburgerBtn && hamburgerBtn.contains(e.target)) {
                hamburgerMenu.classList.toggle('hidden');
            } else if (hamburgerMenu && !hamburgerMenu.contains(e.target)) {
                hamburgerMenu.classList.add('hidden');
            }
        });
    </script>
    <details id="details_cubeUI">
        <summary id="summary_cubeUI">Show Cube Editor</summary>
        <div class="main-container">
            <div class="controls">
                <div class="control-group">
                    <div class="color-setting-row">
                        <label for="color-selector-U">U:</label>
                        <select id="color-selector-U" class="color-selector" data-face="U">
                            <option value="white">White</option>
                            <option value="red">Red</option>
                            <option value="green">Green</option>
                            <option value="yellow">Yellow</option>
                            <option value="orange">Orange</option>
                            <option value="blue">Blue</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="color" id="custom-color-picker-U" class="custom-color-picker hidden" data-face="U"
                            value="#ffffff">
                    </div>
                    <div class="color-setting-row">
                        <label for="color-selector-R">R:</label>
                        <select id="color-selector-R" class="color-selector" data-face="R">
                            <option value="red">Red</option>
                            <option value="white">White</option>
                            <option value="green">Green</option>
                            <option value="yellow">Yellow</option>
                            <option value="orange">Orange</option>
                            <option value="blue">Blue</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="color" id="custom-color-picker-R" class="custom-color-picker hidden" data-face="R"
                            value="#ff0000">
                    </div>
                    <div class="color-setting-row">
                        <label for="color-selector-F">F:</label>
                        <select id="color-selector-F" class="color-selector" data-face="F">
                            <option value="green">Green</option>
                            <option value="white">White</option>
                            <option value="red">Red</option>
                            <option value="yellow">Yellow</option>
                            <option value="orange">Orange</option>
                            <option value="blue">Blue</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="color" id="custom-color-picker-F" class="custom-color-picker hidden" data-face="F"
                            value="#00ff00">
                    </div>
                    <div class="color-setting-row">
                        <label for="color-selector-D">D:</label>
                        <select id="color-selector-D" class="color-selector" data-face="D">
                            <option value="yellow">Yellow</option>
                            <option value="white">White</option>
                            <option value="red">Red</option>
                            <option value="green">Green</option>
                            <option value="orange">Orange</option>
                            <option value="blue">Blue</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="color" id="custom-color-picker-D" class="custom-color-picker hidden" data-face="D"
                            value="#ffff00">
                    </div>
                    <div class="color-setting-row">
                        <label for="color-selector-L">L:</label>
                        <select id="color-selector-L" class="color-selector" data-face="L">
                            <option value="orange">Orange</option>
                            <option value="white">White</option>
                            <option value="red">Red</option>
                            <option value="green">Green</option>
                            <option value="yellow">Yellow</option>
                            <option value="blue">Blue</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="color" id="custom-color-picker-L" class="custom-color-picker hidden" data-face="L"
                            value="#ffa500">
                    </div>
                    <div class="color-setting-row">
                        <label for="color-selector-B">B:</label>
                        <select id="color-selector-B" class="color-selector" data-face="B">
                            <option value="blue">Blue</option>
                            <option value="white">White</option>
                            <option value="red">Red</option>
                            <option value="green">Green</option>
                            <option value="yellow">Yellow</option>
                            <option value="orange">Orange</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="color" id="custom-color-picker-B" class="custom-color-picker hidden" data-face="B"
                            value="#0000ff">
                    </div>
                </div>

                <div class="control-group">
                    <button id="swap-mode-btn" class="mode-button active">Swap</button>
                    <button id="flip-mode-btn" class="mode-button">Flip</button>
                    <button id="ui_solve_btn" class="mode-button">Get<br>Scramble</button>
                    <button id="reset-cube-btn" class="action-button">Reset</button>
                    <label for="rot">Rotation: </label>
                    <select translate="no" id="pre_rot">
                        <option translate="no" value="">None</option>
                        <option translate="no" value="y">y</option>
                        <option translate="no" value="y2">y2</option>
                        <option translate="no" value="y'">y'</option>
                        <option translate="no" value="z2">z2</option>
                        <option translate="no" value="z2 y">z2 y</option>
                        <option translate="no" value="z2 y2">z2 y2</option>
                        <option translate="no" value="z2 y'">z2 y'</option>
                        <option translate="no" value="z'">z'</option>
                        <option translate="no" value="z' y">z' y</option>
                        <option translate="no" value="z' y2">z' y2</option>
                        <option translate="no" value="z' y'">z' y'</option>
                        <option translate="no" value="z">z</option>
                        <option translate="no" value="z y">z y</option>
                        <option translate="no" value="z y2">z y2</option>
                        <option translate="no" value="z y'">z y'</option>
                        <option translate="no" value="x'">x'</option>
                        <option translate="no" value="x' y">x' y</option>
                        <option translate="no" value="x' y2">x' y2</option>
                        <option translate="no" value="x' y'">x' y'</option>
                        <option translate="no" value="x2">x2</option>
                        <option translate="no" value="x2 y">x2 y</option>
                        <option translate="no" value="x2 y2">x2 y2</option>
                        <option translate="no" value="x2 y'">x2 y'</option>
                        <option translate="no" value="x">x</option>
                        <option translate="no" value="x y">x y</option>
                        <option translate="no" value="x y2">x y2</option>
                        <option translate="no" value="x y'">x y'</option>
                    </select>
                </div>
            </div>
            <div class="cube-scroll-container">
                <div id="cube-container" class="unfolded-cube">
                </div>
            </div>
        </div>
    </details>
    <label for="solver">Solver: </label><br>
    <select translate="no" id="solver" onchange="change(); updateUrlParams();">
        <option translate="no" value="F2L" selected>F2L Lite</option>
        <option translate="no" value="F2L_pair">Pairing</option>
        <option translate="no" value="PF2L">Pseudo F2L Lite</option>
        <option translate="no" value="PF2L_pair">Pseudo Pairing</option>
        <option translate="no" value="EOCross">EOCross</option>
        <option translate="no" value="LS">LL Substeps Lite</option>
        <option translate="no" value="LL">LL Lite</option>
        <option translate="no" value="LU">LL AUF Lite</option>
        <option translate="no" value="twophase">Two Phase</option>
        <option translate="no" value="F2L2">F2L</option>
        <option translate="no" value="LS2">LL Substeps</option>
        <option translate="no" value="LL2">LL</option>
        <option translate="no" value="LU2">LL AUF</option>
    </select><br>
    <label for="scr">Scramble: </label><br>
    <textarea id="scr" rows="10" cols="10" placeholder="Use // to write comments, as in algs // comment. 
Write the //setup comment in the appropriate position when viewing on alg.cubing.net or cubedb.net."
        onchange="save()"></textarea><br>
    <button id="gen" class="button medium" onclick="genscr()">Random</button>
    <button id="reverse" class="button medium" onclick="reverseScramble()">Reverse</button>
    <button id="mirror" class="button medium" onclick="mirrorScramble()">Mirror</button>
    <button id="clear" class="button medium">Clear</button>
    <button id="undo" class="button small hidden_small" onclick="undo()">←</button>
    <button id="redo" class="button small hidden_small" onclick="redo()">→</button><br>
    <details id="details_preview">
        <summary id="summary_preview">Show Preview</summary>
        <div id="show"></div>
        <pre id="links"
            class="hidden"><a translate="no" id="link_alg_cubing" href="https://alg.cubing.net/" target="_blank" rel="noopener noreferrer">alg.cubing.net</a>  <a translate="no" id="link_cubedb" href="https://cubedb.net/?puzzle=3x3" target="_blank" rel="noopener noreferrer">cubedb.net</a></pre>
    </details>
    <details id="analyze">
        <summary id="summary_analyzer">Show Analyzer</summary><br>
        <label for="analyzer_rotation_option">Face Option: </label>
        <fieldset id="analyzer_rotation_option">
            <input type="checkbox" id="checkboxD_analyzer" class="custom-checkbox analyzer" value="D" checked>
            <label translate="no" for="checkboxD_analyzer">D</label>
            <input type="checkbox" id="checkboxU_analyzer" class="custom-checkbox analyzer" value="U">
            <label translate="no" for="checkboxU_analyzer">U</label>
            <input type="checkbox" id="checkboxL_analyzer" class="custom-checkbox analyzer" value="L">
            <label translate="no" for="checkboxL_analyzer">L</label>
            <input type="checkbox" id="checkboxR_analyzer" class="custom-checkbox analyzer" value="R">
            <label translate="no" for="checkboxR_analyzer">R</label>
            <input type="checkbox" id="checkboxF_analyzer" class="custom-checkbox analyzer" value="F">
            <label translate="no" for="checkboxF_analyzer">F</label>
            <input type="checkbox" id="checkboxB_analyzer" class="custom-checkbox analyzer" value="B">
            <label translate="no" for="checkboxB_analyzer">B</label>
        </fieldset>
        <label for="analyzer_option">Solver Option: </label>
        <select translate="no" id="analyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="analyzer_num">Count: </label>
        <input type="number" id="analyzer_num" value="1" min="1" required><br>
        <button id="analyzer" class="button medium" onclick="analyze()">Analyze</button><br>
        <div id="table"></div>
    </details>

    <details id="eo_analyze">
        <summary id="summary_eo_analyzer">Show Analyzer</summary><br>
        <label for="eo_analyzer_rotation_option">Face Option: </label>
        <fieldset id="eo_analyzer_rotation_option">
            <input type="checkbox" id="checkboxD_eo_analyzer" class="custom-checkbox eo_analyzer" value="D" checked>
            <label translate="no" for="checkboxD_eo_analyzer">D</label>
            <input type="checkbox" id="checkboxU_eo_analyzer" class="custom-checkbox eo_analyzer" value="U">
            <label translate="no" for="checkboxU_eo_analyzer">U</label>
            <input type="checkbox" id="checkboxL_eo_analyzer" class="custom-checkbox eo_analyzer" value="L">
            <label translate="no" for="checkboxL_eo_analyzer">L</label>
            <input type="checkbox" id="checkboxR_eo_analyzer" class="custom-checkbox eo_analyzer" value="R">
            <label translate="no" for="checkboxR_eo_analyzer">R</label>
            <input type="checkbox" id="checkboxF_eo_analyzer" class="custom-checkbox eo_analyzer" value="F">
            <label translate="no" for="checkboxF_eo_analyzer">F</label>
            <input type="checkbox" id="checkboxB_eo_analyzer" class="custom-checkbox eo_analyzer" value="B">
            <label translate="no" for="checkboxB_eo_analyzer">B</label>
        </fieldset>
        <label for="eo_analyzer_option">Solver Option: </label>
        <select translate="no" id="eo_analyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="eo_analyzer_num">Count: </label>
        <input type="number" id="eo_analyzer_num" value="1" min="1" required><br>
        <button id="eo_analyzer" class="button medium" onclick="eo_analyze()">Analyze</button>
        <div id="eo_table"></div>
    </details>

    <details id="panalyze">
        <summary id="summary_panalyzer">Show Analyzer</summary><br>
        <label for="panalyzer_rotation_option">Face Option: </label>
        <fieldset id="panalyzer_rotation_option">
            <input type="checkbox" id="checkboxD_panalyzer" class="custom-checkbox panalyzer" value="D" checked>
            <label translate="no" for="checkboxD_panalyzer">D</label>
            <input type="checkbox" id="checkboxU_panalyzer" class="custom-checkbox panalyzer" value="U">
            <label translate="no" for="checkboxU_panalyzer">U</label>
            <input type="checkbox" id="checkboxL_panalyzer" class="custom-checkbox panalyzer" value="L">
            <label translate="no" for="checkboxL_panalyzer">L</label>
            <input type="checkbox" id="checkboxR_panalyzer" class="custom-checkbox panalyzer" value="R">
            <label translate="no" for="checkboxR_panalyzer">R</label>
            <input type="checkbox" id="checkboxF_panalyzer" class="custom-checkbox panalyzer" value="F">
            <label translate="no" for="checkboxF_panalyzer">F</label>
            <input type="checkbox" id="checkboxB_panalyzer" class="custom-checkbox panalyzer" value="B">
            <label translate="no" for="checkboxB_panalyzer">B</label>
        </fieldset>
        <label for="panalyzer_option">Solver Option: </label>
        <select translate="no" id="panalyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="panalyzer_num">Count: </label>
        <input type="number" id="panalyzer_num" value="1" min="1" required><br>
        <button id="panalyzer" class="button medium" onclick="panalyze()">Analyze</button>
        <div id="ptable"></div>
    </details>

    <details id="pair_analyze">
        <summary id="summary_pair_analyzer">Show Analyzer</summary><br>
        <label for="pair_analyzer_rotation_option">Face Option: </label>
        <fieldset id="pair_analyzer_rotation_option">
            <input type="checkbox" id="checkboxD_pair_analyzer" class="custom-checkbox pair_analyzer" value="D" checked>
            <label translate="no" for="checkboxD_pair_analyzer">D</label>
            <input type="checkbox" id="checkboxU_pair_analyzer" class="custom-checkbox pair_analyzer" value="U">
            <label translate="no" for="checkboxU_pair_analyzer">U</label>
            <input type="checkbox" id="checkboxL_pair_analyzer" class="custom-checkbox pair_analyzer" value="L">
            <label translate="no" for="checkboxL_pair_analyzer">L</label>
            <input type="checkbox" id="checkboxR_pair_analyzer" class="custom-checkbox pair_analyzer" value="R">
            <label translate="no" for="checkboxR_pair_analyzer">R</label>
            <input type="checkbox" id="checkboxF_pair_analyzer" class="custom-checkbox pair_analyzer" value="F">
            <label translate="no" for="checkboxF_pair_analyzer">F</label>
            <input type="checkbox" id="checkboxB_pair_analyzer" class="custom-checkbox pair_analyzer" value="B">
            <label translate="no" for="checkboxB_pair_analyzer">B</label>
        </fieldset>
        <label for="pair_analyzer_option">Solver Option: </label>
        <select translate="no" id="pair_analyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="pair_analyzer_num">Count: </label>
        <input type="number" id="pair_analyzer_num" value="1" min="1" required><br>
        <button id="pair_analyzer" class="button medium" onclick="pair_analyze()">Analyze</button>
        <div id="pair_table"></div>
    </details>

    <details id="pair_panalyze">
        <summary id="summary_pair_panalyzer">Show Analyzer</summary><br>
        <label for="pair_panalyzer_rotation_option">Face Option: </label>
        <fieldset id="pair_panalyzer_rotation_option">
            <input type="checkbox" id="checkboxD_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="D"
                checked>
            <label translate="no" for="checkboxD_pair_panalyzer">D</label>
            <input type="checkbox" id="checkboxU_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="U">
            <label translate="no" for="checkboxU_pair_panalyzer">U</label>
            <input type="checkbox" id="checkboxL_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="L">
            <label translate="no" for="checkboxL_pair_panalyzer">L</label>
            <input type="checkbox" id="checkboxR_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="R">
            <label translate="no" for="checkboxR_pair_panalyzer">R</label>
            <input type="checkbox" id="checkboxF_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="F">
            <label translate="no" for="checkboxF_pair_panalyzer">F</label>
            <input type="checkbox" id="checkboxB_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="B">
            <label translate="no" for="checkboxB_pair_panalyzer">B</label>
        </fieldset>
        <label for="pair_panalyzer_option">Solver Option: </label>
        <select translate="no" id="pair_panalyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="pair_panalyzer_num">Count: </label>
        <input type="number" id="pair_panalyzer_num" value="1" min="1" required><br>
        <button id="pair_panalyzer" class="button medium" onclick="pair_panalyze()">Analyze</button>
        <div id="pair_ptable"></div>
    </details><br>

    <label for="rot">Rotation: </label>
    <select translate="no" id="rot" onchange="updateUrlParams()">
        <option translate="no" value="">None</option>
        <option translate="no" value="y">y</option>
        <option translate="no" value="y2">y2</option>
        <option translate="no" value="y'">y'</option>
        <option translate="no" value="z2">z2</option>
        <option translate="no" value="z2 y">z2 y</option>
        <option translate="no" value="z2 y2">z2 y2</option>
        <option translate="no" value="z2 y'">z2 y'</option>
        <option translate="no" value="z'">z'</option>
        <option translate="no" value="z' y">z' y</option>
        <option translate="no" value="z' y2">z' y2</option>
        <option translate="no" value="z' y'">z' y'</option>
        <option translate="no" value="z">z</option>
        <option translate="no" value="z y">z y</option>
        <option translate="no" value="z y2">z y2</option>
        <option translate="no" value="z y'">z y'</option>
        <option translate="no" value="x'">x'</option>
        <option translate="no" value="x' y">x' y</option>
        <option translate="no" value="x' y2">x' y2</option>
        <option translate="no" value="x' y'">x' y'</option>
        <option translate="no" value="x2">x2</option>
        <option translate="no" value="x2 y">x2 y</option>
        <option translate="no" value="x2 y2">x2 y2</option>
        <option translate="no" value="x2 y'">x2 y'</option>
        <option translate="no" value="x">x</option>
        <option translate="no" value="x y">x y</option>
        <option translate="no" value="x y2">x y2</option>
        <option translate="no" value="x y'">x y'</option>
    </select><br>
    <div id="option_for_F2L" class="hidden">
        <label for="slot">Slot: </label>
        <select translate="no" id="slot" onchange="updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
            <option translate="no" value="BL BR">BL BR</option>
            <option translate="no" value="BL FR">BL FR</option>
            <option translate="no" value="BL FL">BL FL</option>
            <option translate="no" value="BR FR">BR FR</option>
            <option translate="no" value="BR FL">BR FL</option>
            <option translate="no" value="FR FL">FR FL</option>
            <option translate="no" value="BL BR FR">BL BR FR</option>
            <option translate="no" value="BL BR FL">BL BR FL</option>
            <option translate="no" value="BL FR FL">BL FR FL</option>
            <option translate="no" value="BR FR FL">BR FR FL</option>
            <option translate="no" value="BL BR FR FL">BL BR FR FL</option>
        </select>
    </div>
    <div id="option_for_PF2L" class="hidden">
        <div id="option_for_PF2LE">
            <label for="pslot_edge">Pseudo Slot Edge: </label>
            <select translate="no" id="pslot_edge" onchange="updateDropdown(); updateUrlParams();">
                <option translate="no" value="">None</option>
                <option translate="no" value="BL">BL</option>
                <option translate="no" value="BR">BR</option>
                <option translate="no" value="FR">FR</option>
                <option translate="no" value="FL">FL</option>
                <option translate="no" value="BL BR">BL BR</option>
                <option translate="no" value="BL FR">BL FR</option>
                <option translate="no" value="BL FL">BL FL</option>
                <option translate="no" value="BR FR">BR FR</option>
                <option translate="no" value="BR FL">BR FL</option>
                <option translate="no" value="FR FL">FR FL</option>
                <option translate="no" value="BL BR FR">BL BR FR</option>
                <option translate="no" value="BL BR FL">BL BR FL</option>
                <option translate="no" value="BL FR FL">BL FR FL</option>
                <option translate="no" value="BR FR FL">BR FR FL</option>
            </select>
        </div>
        <div id="option_for_PF2LC" class="hidden">
            <label for="pslot_corner">Pseudo Slot Corner: </label>
            <select translate="no" id="pslot_corner" onchange="updateUrlParams()">
            </select>
        </div>
    </div>

    <div id="option_for_F2L2" class="hidden">
        <label for="slot2">Slot: </label>
        <select translate="no" id="slot2" onchange="updateDropdown2(); updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
            <option translate="no" value="BL BR">BL BR</option>
            <option translate="no" value="BL FR">BL FR</option>
            <option translate="no" value="BL FL">BL FL</option>
            <option translate="no" value="BR FR">BR FR</option>
            <option translate="no" value="BR FL">BR FL</option>
            <option translate="no" value="FR FL">FR FL</option>
            <option translate="no" value="BL BR FR">BL BR FR</option>
            <option translate="no" value="BL BR FL">BL BR FL</option>
            <option translate="no" value="BL FR FL">BL FR FL</option>
            <option translate="no" value="BR FR FL">BR FR FL</option>
        </select>
    </div>
    <div id="option_for_pair_F2L" class="hidden">
        <label for="pair_slot">Free Pair: </label>
        <select translate="no" id="pair_slot" onchange="updateUrlParams()">
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
        </select>
    </div>
    <div id="option_for_PF2L2" class="hidden">
        <div id="option_for_PF2LE2">
            <label for="pslot_edge2">Pseudo Slot Edge: </label>
            <select translate="no" id="pslot_edge2" onchange="updateDropdown3(); updateUrlParams()">
                <option translate="no" value="">None</option>
                <option translate="no" value="BL">BL</option>
                <option translate="no" value="BR">BR</option>
                <option translate="no" value="FR">FR</option>
                <option translate="no" value="FL">FL</option>
                <option translate="no" value="BL BR">BL BR</option>
                <option translate="no" value="BL FR">BL FR</option>
                <option translate="no" value="BL FL">BL FL</option>
                <option translate="no" value="BR FR">BR FR</option>
                <option translate="no" value="BR FL">BR FL</option>
                <option translate="no" value="FR FL">FR FL</option>
                <option translate="no" value="BL BR FR">BL BR FR</option>
                <option translate="no" value="BL BR FL">BL BR FL</option>
                <option translate="no" value="BL FR FL">BL FR FL</option>
                <option translate="no" value="BR FR FL">BR FR FL</option>
            </select>
        </div>
        <div id="option_for_PF2LC2" class="hidden">
            <label for="pslot_corner2">Pseudo Slot Corner: </label>
            <select translate="no" id="pslot_corner2" onchange="updateDropdown4(); updateUrlParams()">
            </select>
        </div>
        <div id="option_for_pair_PF2L" class="hidden">
            <div id="option_for_pair_PF2LE">
                <label for="pair_pslot_edge">Free Pair Edge: </label>
                <select translate="no" id="pair_pslot_edge" onchange="updateUrlParams()">
                    <option translate="no" value="BL">BL</option>
                    <option translate="no" value="BR">BR</option>
                    <option translate="no" value="FR">FR</option>
                    <option translate="no" value="FL">FL</option>
                </select>
            </div>
            <div id="option_for_pair_PF2LC">
                <label for="pair_pslot_corner">Free Pair Corner: </label>
                <select translate="no" id="pair_pslot_corner" onchange="updateUrlParams()">
                    <option translate="no" value="BL">BL</option>
                    <option translate="no" value="BR">BR</option>
                    <option translate="no" value="FR">FR</option>
                    <option translate="no" value="FL">FL</option>
                </select>
            </div>
        </div>
    </div>
    <div id="option_for_eocross" class="hidden">
        <label for="slot_eo">Slot: </label>
        <select translate="no" id="slot_eo" onchange="updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
            <option translate="no" value="BL BR">BL BR</option>
            <option translate="no" value="BL FR">BL FR</option>
            <option translate="no" value="BL FL">BL FL</option>
            <option translate="no" value="BR FR">BR FR</option>
            <option translate="no" value="BR FL">BR FL</option>
            <option translate="no" value="FR FL">FR FL</option>
            <option translate="no" value="BL BR FR">BL BR FR</option>
            <option translate="no" value="BL BR FL">BL BR FL</option>
            <option translate="no" value="BL FR FL">BL FR FL</option>
            <option translate="no" value="BR FR FL">BR FR FL</option>
            <option translate="no" value="BL BR FR FL">BL BR FR FL</option>
        </select>
    </div>

    <div id="option_for_LS" class="hidden">
        <label for="ll">Last Layer Option: </label>
        <select translate="no" id="ll" onchange="updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="CP">CP</option>
            <option translate="no" value="CO">CO</option>
            <option translate="no" value="EP">EP</option>
            <option translate="no" value="EO">EO</option>
            <option translate="no" value="CP CO">CP CO</option>
            <option translate="no" value="CP EP">CP EP</option>
            <option translate="no" value="CP EO">CP EO</option>
            <option translate="no" value="CO EP">CO EP</option>
            <option translate="no" value="CO EO">CO EO</option>
            <option translate="no" value="EP EO">EP EO</option>
            <option translate="no" value="CP CO EP">CP CO EP</option>
            <option translate="no" value="CP CO EO">CP CO EO</option>
            <option translate="no" value="CP EO EP">CP EO EP</option>
            <option translate="no" value="CO EP EO">CO EP EO</option>
            <option translate="no" value="CP CO EP EO">CP CO EP EO</option>
        </select>
    </div>
    <div id="basic input">
        <label for="len">Max Length: </label>
        <input type="number" id="len" value="20" min="1" required onchange="updateUrlParams()"><br>
        <label for="num">Max Count: </label>
        <input type="number" id="num" value="20" min=1 required onchange="updateUrlParams()"><br>
        <label for="res">Move Restrict: </label>
        <div translate="no" id="res" onchange="updateUrlParams()">

            <table class="checkbox-table">
                <tbody>
                    <tr>
                        <td>
                            <input type="checkbox" id="checkboxU_restrict" class="custom-checkbox restrict" value="U"
                                checked>
                            <label translate="no" for="checkboxU_restrict">U</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxD_restrict" class="custom-checkbox restrict" value="D"
                                checked>
                            <label translate="no" for="checkboxD_restrict">D</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxL_restrict" class="custom-checkbox restrict" value="L"
                                checked>
                            <label translate="no" for="checkboxL_restrict">L</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxR_restrict" class="custom-checkbox restrict" value="R"
                                checked>
                            <label translate="no" for="checkboxR_restrict">R</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxF_restrict" class="custom-checkbox restrict" value="F"
                                checked>
                            <label translate="no" for="checkboxF_restrict">F</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxB_restrict" class="custom-checkbox restrict" value="B"
                                checked>
                            <label translate="no" for="checkboxB_restrict">B</label>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <input type="checkbox" id="checkboxu_restrict" class="custom-checkbox restrict" value="u">
                            <label translate="no" for="checkboxu_restrict">u</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxd_restrict" class="custom-checkbox restrict" value="d">
                            <label translate="no" for="checkboxd_restrict">d</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxl_restrict" class="custom-checkbox restrict" value="l">
                            <label translate="no" for="checkboxl_restrict">l</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxr_restrict" class="custom-checkbox restrict" value="r">
                            <label translate="no" for="checkboxr_restrict">r</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxf_restrict" class="custom-checkbox restrict" value="f">
                            <label translate="no" for="checkboxf_restrict">f</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxb_restrict" class="custom-checkbox restrict" value="b">
                            <label translate="no" for="checkboxb_restrict">b</label>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <input type="checkbox" id="checkboxM_restrict" class="custom-checkbox restrict" value="M">
                            <label translate="no" for="checkboxM_restrict">M</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxE_restrict" class="custom-checkbox restrict" value="E">
                            <label translate="no" for="checkboxE_restrict">E</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxS_restrict" class="custom-checkbox restrict" value="S">
                            <label translate="no" for="checkboxS_restrict">S</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxx_restrict" class="custom-checkbox restrict" value="x">
                            <label translate="no" for="checkboxx_restrict">x</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxy_restrict" class="custom-checkbox restrict" value="y">
                            <label translate="no" for="checkboxy_restrict">y</label>
                        </td>
                        <td>
                            <input type="checkbox" id="checkboxz_restrict" class="custom-checkbox restrict" value="z">
                            <label translate="no" for="checkboxz_restrict">z</label>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div><br>

        <details id="advancedSettings">
            <summary id="summaryAdvancedSettings">Show Advanced Settings</summary><br>
            <label for="premove">Pre Move: </label>
            <input type="text" id="premove" onchange="updateUrlParams()"><br>
            <label for="res_table">Move Restrict:</label>
            <div id="res_table_wrapper" onchange="updateUrlParams()">
                <table id="res_table" border="2" translate="no">
                    <thead>
                        <tr>
                            <th></th>
                            <th>* </th>
                            <th>* 2 </th>
                            <th>* ' </th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div><br>
            <label for="move_available_table">Move Available Table:</label>
            <div id="move_available_table_wrapper" onchange="updateUrlParams()">
                <table id="move_available_table" border="2" translate="no">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div><br>
            <label for="center_restrict">Center Restrict:</label>
            <div id="center_restrict_wrapper" onchange="updateUrlParams()">
                <table id="center_restrict" border="2" translate="no">
                    <thead>
                        <tr>
                            <th></th>
                            <th>* </th>
                            <th>* y</th>
                            <th>* y2</th>
                            <th>* y'</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th> </th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_EMPTY"
                                    class="custom-checkbox restrict" checked>
                                <label for="checkbox_center_restrict_EMPTY_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_EMPTY_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_EMPTY_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_EMPTY_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>z2</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>z'</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>z</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>x'</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>x</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_y-"></label>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div><br>
            <label for="rot_count">Max Rotation Count: </label>
            <input type="number" id="rot_count" value=0 min=0 required onchange="updateUrlParams()"><br>
            <label for="count_table">Max Move Count:</label>
            <div id="count_table_wrapper">
                <table id="count_table" border="2" translate="no">
                    <thead>
                        <tr>
                            <th></th>
                            <th>* </th>
                            <th>* 2 </th>
                            <th>* ' </th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div><br>
        </details>
        <br>
        <input type="checkbox" id="CheckboxAutoMaskSetting" class="custom-checkbox" checked>
        <label for="CheckboxAutoMaskSetting">Auto Stickering Setting </label>

        <details id="maskOptions">
            <summary id="summaryMaskOptions">Show Stickering Settings</summary>
            <div id="preview"></div><br>
            <button id="autoSetMask" class="button medium" onclick="setStickeringOptionAuto()">Auto</button>
            <button id="resetMask" class="button medium" onclick="resetStickeringOptions('-')">Reset</button><br><br>
            <div id="maskOptionsCenterDiv">
                <label for="maskOptionCenter">Centers: </label>
                <select id="maskOptionCenter">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="I">Ignored</option>
                </select>
            </div>
            <label for="maskOptionsEdge">Edges Options</label><br>
            <div id="maskOptionsEdge">
                <label for="maskOptionDE">Cross: </label>
                <select id="maskOptionDE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionBLE">BL Slot: </label>
                <select id="maskOptionBLE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionBRE">BR Slot: </label>
                <select id="maskOptionBRE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFRE">FR Slot: </label>
                <select id="maskOptionFRE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFLE">FL Slot: </label>
                <select id="maskOptionFLE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionLLE">Last Layer: </label>
                <select id="maskOptionLLE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select>
            </div>
            <label for="maskOptionsCorner">Corners Options</label><br>
            <div id="maskOptionsCorner">
                <label for="maskOptionBLC">BL Slot: </label>
                <select id="maskOptionBLC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionBRC">BR Slot: </label>
                <select id="maskOptionBRC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFRC">FR Slot: </label>
                <select id="maskOptionFRC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFLC">FL Slot: </label>
                <select id="maskOptionFLC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionLLC">Last Layer: </label>
                <select id="maskOptionLLC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select>
            </div>
        </details>
    </div>
    <a class="hidden" id="tp_alert">Two Phase Solver output 1 solution.</a><br>
    <button id="solveButton" class="button medium" onclick="startWorker()">Start</button>&nbsp;&nbsp;
    <button onclick="showModalWithCustomText()" class="button medium">Export</button><br>
    <div id="modal-overlay" class="modal-overlay hidden">
        <div id="modal-panel" class="modal-panel">
            <div class="modal-header">
                <div class="header-left-group">
                    <h2>Output</h2>
                    <button id="modal-copy-btn" class="button copy-btn">Copy</button>
                </div>
                <button id="modal-close-btn" class="close-btn">&times;</button>
            </div>
            <div class="modal-content">
                <pre id="modal-text-content" translate="no"></pre>
            </div>
        </div>
    </div>
    <label for="countLine">Number of solutions: </label>
    <input type="text" id="countLine" value="0" readonly><br>
    <label for="currentDepth">Current Depth: </label>
    <input type="text" id="currentDepth" value="-1" readonly>
    <div id="result"></div>

    <script type="module">
        import { TwistyPlayer } from "https://cdn.cubing.net/v0/js/cubing/twisty";
        function createPlayer(setup, sol) {
            const player = new TwistyPlayer({
                puzzle: "3x3x3",
                experimentalSetupAlg: setup,
                alg: sol,
                background: "none"
            });
            return player;
        }
        window.createPlayer = createPlayer;
    </script>

    <script>
        const functionsPromise = new Promise(resolve => {
            window.Module = {
                onRuntimeInitialized: () => resolve(window.Module)
            };
        });
    </script>
    <script src="src/functions/functions.js"></script>

    <script>
        let reverse;
        let mirror;
        let convert;
        let generateTwoPhaseInput;
        let convertMask;
        let isFunctionsReady = false;

        async function InitializeFunctions() {
            const Module = await functionsPromise;
            reverse = function (scr) {
                const scr_fixed = scr_fix2(scr);
                if (scr_fixed === "") {
                    return;
                }
                const lines = scr_fixed.split('\n');
                const processedLines = [];
                for (let i = lines.length - 1; i >= 0; i--) {
                    const line = lines[i];
                    const [alg, comment] = line.split('//');
                    const alg_revresed = Module.scr_reverse(alg.trim());
                    if (comment) {
                        processedLines.push(`${alg_revresed} // ${comment.trim()}`);
                    } else {
                        processedLines.push(alg_revresed);
                    }
                }
                const result = processedLines.join('\n');
                return result.trim() + "\n";
            };
            mirror = function (scr) {
                const scr_fixed = scr_fix2(scr);
                if (scr_fixed === "") {
                    return;
                }
                const lines = scr_fixed.split('\n');
                const processedLines = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const [alg, comment] = line.split('//');
                    const alg_mirrored = Module.scr_mirror(alg.trim());
                    if (comment) {
                        processedLines.push(`${alg_mirrored} // ${comment.trim()}`);
                    } else {
                        processedLines.push(alg_mirrored);
                    }
                }
                const result = processedLines.join('\n');
                return result.trim() + "\n";
            };
            convert = function (scramble) {
                const result = Module.scr_converter(scramble);
                const resultArray = result.split(',');
                return resultArray.map(part => part.trim());
            };
            generateTwoPhaseInput = function (scramble) {
                const result = Module.ScrambleToState(scramble);
                return result;
            };
            convertMask = function (center_input, edge_input, corner_input, rotation_alg) {
                const result = Module.convertMask(center_input, edge_input, corner_input, rotation_alg);
                return result;
            };
            isFunctionsReady = true;
        }

        InitializeFunctions();

        let worker;
        let worker2;
        let worker3;
        let worker4;
        let worker5;
        let worker6;
        let messageCount = 0;
        let messageCount_analyzer = 0;
        let messageCount_panalyzer = 0;
        let messageCount_pair_analyzer = 0;
        let messageCount_pair_panalyze = 0;
        let messageCount_eo_analyzer = 0;
        let option_table;
        let option_ptable;
        let option_pair_table;
        let option_pair_ptable;
        let option_eo_table;
        let list_table;
        let list_ptable;
        let list_pair_table;
        let list_pair_ptable;
        let list_eo_table;
        let sol_input = false;
        let AutoMaskSetting = true;
        let mask = {
            orbits: {
                EDGES: {
                    pieces: [
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                    ],
                },
                CORNERS: {
                    pieces: [
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                    ],
                },
                CENTERS: {
                    pieces: [
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                    ],
                },
            },
        };
        let tmp_mask = mask;
        let body = "";

        function getMaskInputs() {
            const maskInputCenter = document.getElementById("maskOptionCenter").value;
            const selectsEdges = document.querySelectorAll('#maskOptionsEdge select');
            const selectsCorners = document.querySelectorAll('#maskOptionsCorner select');
            const selectedValuesEdges = [];
            const selectedValuesCorners = [];
            selectsEdges.forEach(select => {
                selectedValuesEdges.push(select.value);
            });
            selectsCorners.forEach(select => {
                selectedValuesCorners.push(select.value);
            });
            const maskInputEdges = selectedValuesEdges.join('');
            const maskInputCorners = selectedValuesCorners.join('');
            return { maskInputCenter, maskInputEdges, maskInputCorners };
        }

        function resetStickeringOptions(option) {
            const selectAll = document.querySelectorAll('#maskOptions select');
            selectAll.forEach(select => {
                select.value = option;
            });
            setMaskTmp();
        }

        function setStickeringOptionsAutoF2LEdges(slot_edges, option) {
            if (slot_edges !== '') {
                const selectsEdges = slot_edges.split(' ');
                const fixedSelectsEdges = selectsEdges.map(select => 'maskOption' + select + 'E');
                fixedSelectsEdges.forEach(select => {
                    const selectElement = document.querySelector(`#maskOptionsEdge select[id*="${select}"]`);
                    if (selectElement) {
                        selectElement.value = option;
                    }
                });
            }
        }

        function setStickeringOptionsAutoF2LCorners(slot_corners, option) {
            if (slot_corners !== '') {
                const selectsCorners = slot_corners.split(' ');
                const fixedSelectsCorners = selectsCorners.map(select => 'maskOption' + select + 'C');
                fixedSelectsCorners.forEach(select => {
                    const selectElement = document.querySelector(`#maskOptionsCorner select[id*="${select}"]`);
                    if (selectElement) {
                        selectElement.value = option;
                    }
                });
            }
        }

        function setStickeringOptionsAutoEO(option) {
            document.getElementById("maskOptionLLE").value = '?';
            setStickeringOptionsAutoF2LEdges('BL BR FR FL', '?');
        }

        function setStickeringOptionAutoLL(ll) {
            resetStickeringOptions('D');
            document.getElementById("maskOptionLLE").value = 'I';
            document.getElementById("maskOptionLLC").value = 'I';
            if (ll !== '') {
                const option_array = ll.split(' ');
                option_array.forEach(option => {
                    switch (option) {
                        case 'CO':
                            document.getElementById("maskOptionLLC").value = '?';
                            break;
                        case 'CP':
                            document.getElementById("maskOptionLLC").value = '-';
                            break;
                        case 'EO':
                            document.getElementById("maskOptionLLE").value = '?';
                            break;
                        case 'EP':
                            document.getElementById("maskOptionLLE").value = '-';
                            break;
                    }
                });
            }
        }

        function setStickeringOptionAuto() {
            const solver = document.getElementById("solver").value;
            var slot, pslote, pslotc, ll;
            switch (solver) {
                case "F2L":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById("maskOptionDE").value = '-';
                    slot = document.getElementById("slot").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "F2L2":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById("maskOptionDE").value = '-';
                    slot = document.getElementById("slot").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "F2L_pair":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById('maskOptionDE').value = '-';
                    slot = document.getElementById("slot2").value + ' ' + document.getElementById("pair_slot").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "PF2L":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById('maskOptionDE').value = '-';
                    pslote = document.getElementById("pslot_edge").value;
                    pslotc = document.getElementById("pslot_corner").value;
                    setStickeringOptionsAutoF2LEdges(pslote, '-');
                    setStickeringOptionsAutoF2LCorners(pslotc, '-');
                    setMaskTmp();
                    break;
                case "PF2L_pair":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById('maskOptionDE').value = '-';
                    pslote = document.getElementById("pslot_edge2").value + ' ' + document.getElementById("pair_pslot_edge").value;
                    pslotc = document.getElementById("pslot_corner2").value + ' ' + document.getElementById("pair_pslot_corner").value;
                    setStickeringOptionsAutoF2LEdges(pslote, '-');
                    setStickeringOptionsAutoF2LCorners(pslotc, '-');
                    setMaskTmp();
                    break;
                case "EOCross":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    setStickeringOptionsAutoEO('?');
                    document.getElementById('maskOptionDE').value = '-';
                    slot = document.getElementById("slot_eo").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "LS":
                case "LS2":
                    ll = document.getElementById("ll").value;
                    setStickeringOptionAutoLL(ll);
                    setMaskTmp();
                    break;
                case "LL":
                case "LL2":
                case "LU":
                case "LU2":
                    setStickeringOptionAutoLL('CP EP');
                    setMaskTmp();
                    break;
                case "twophase":
                    resetStickeringOptions('-');
                    break;
            }
        }

        function mapFacelet(char) {
            switch (char) {
                case '-':
                    return 'regular';
                case 'D':
                    return 'dim';
                case 'I':
                    return 'ignored';
                case '?':
                    return 'oriented';
            }
        }

        function setMask(inputString, setTmp = false) {
            const edgesString = inputString.slice(0, 24);
            const cornersString = inputString.slice(24, 48);
            const centersString = inputString.slice(48, 54);
            const edges = [];
            for (let i = 0; i < edgesString.length; i += 2) {
                edges.push({ facelets: [mapFacelet(edgesString[i]), mapFacelet(edgesString[i + 1])] });
            }
            const corners = [];
            for (let i = 0; i < cornersString.length; i += 3) {
                corners.push({ facelets: [mapFacelet(cornersString[i]), mapFacelet(cornersString[i + 1]), mapFacelet(cornersString[i + 2])] });
            }
            const centers = [];
            for (let i = 0; i < centersString.length; i++) {
                centers.push({ facelets: [mapFacelet(centersString[i])] });
            }
            if (setTmp) {
                tmp_mask = {
                    orbits: {
                        EDGES: {
                            pieces: edges,
                        },
                        CORNERS: {
                            pieces: corners,
                        },
                        CENTERS: {
                            pieces: centers,
                        },
                    },
                };
            } else {
                mask = {
                    orbits: {
                        EDGES: {
                            pieces: edges,
                        },
                        CORNERS: {
                            pieces: corners,
                        },
                        CENTERS: {
                            pieces: centers,
                        },
                    },
                };
            }
        }

        function setMaskTmp() {
            if (!isFunctionsReady) {
                alert("The module is still initializing. Please try again in a moment.");
                return;
            }
            if (typeof convertMask !== "function" || typeof convert !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            }
            const rot = document.getElementById('rot').value;
            const scr_val = document.getElementById("scr").value;
            const scr = scr_fix2(scr_val);
            const convertResult = convert(scr);
            const result_rotation = convertResult[1] + " " + rot;
            const mask_input = getMaskInputs();
            const convertedMask = convertMask(mask_input.maskInputCenter, mask_input.maskInputEdges, mask_input.maskInputCorners, result_rotation);
            setMask(convertedMask, true);
            try {
                document.getElementById('preview').innerHTML = '';
                const sim = createPlayer(scr + " " + rot, '');
                sim.controlPanel = "none";
                sim.experimentalStickeringMaskOrbits = tmp_mask;
                document.getElementById('preview').appendChild(sim);
            } catch (e) {
                const content = document.createElement('a');
                content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                document.getElementById('preview').appendChild(content);
            }
        }

        function scr_fix(scr) {
            const fixed_scr = scr_fix2(scr);
            const output = fixed_scr.split('\n')
                .map(line => line.split('//')[0].trim())
                .filter(line => line.length > 0)
                .join('\n');
            return output;
        }

        function scr_fix2(scr) {
            const outputString = scr.split('\n').map(line => {
                const commentIndex = line.indexOf('//');
                if (commentIndex !== -1) {
                    const beforeComment = insertSpaces(line.slice(0, commentIndex));
                    const comment = line.slice(commentIndex);
                    return beforeComment + ' ' + comment.trim();
                } else {
                    return insertSpaces(line);
                }
            }).join('\n');
            return outputString;
        }

        function insertSpaces(input) {
            const keys = ["U", "U2", "U2'", "U'", "D", "D2", "D2'", "D'", "L", "L2", "L2'", "L'", "R", "R2", "R2'", "R'", "F", "F2", "F2'", "F'", "B", "B2", "B2'", "B'", "u", "u2", "u2'", "u'", "d", "d2", "d2'", "d'", "l", "l2", "l2'", "l'", "r", "r2", "r2'", "r'", "f", "f2", "f2'", "f'", "b", "b2", "b2'", "b'", "Uw", "Uw2", "Uw2'", "Uw'", "Dw", "Dw2", "Dw2'", "Dw'", "Lw", "Lw2", "Lw2'", "Lw'", "Rw", "Rw2", "Rw2'", "Rw'", "Fw", "Fw2", "Fw2'", "Fw'", "Bw", "Bw2", "Bw2'", "Bw'", "M", "M2", "M2'", "M'", "S", "S2", "S2'", "S'", "E", "E2", "E2'", "E'", "x", "x2", "x2'", "x'", "y", "y2", "y2'", "y'", "z", "z2", "z2'", "z'"];
            const regex = new RegExp(`(${keys.join('|')})`, 'g');
            return input.replace(regex, ' $1').trim()
                .replace(/\s+/g, ' ');
        }

        function replaceCharacters(input) {
            return input
                .replace(/'/g, '-')
                .replace(/\n/g, '%0A')
                .replace(/\//g, '%2F')
                .replace(/ /g, '_');
        }

        function splitAtLastScramble(input) {
            const scrambleRegex = /\/\/\s*setup/g;
            const index = input.search(scrambleRegex);
            if (index !== -1) {
                const scrambleLineEnd = input.indexOf('\n', index);
                const scrambleLine = input.slice(index, scrambleLineEnd !== -1 ? scrambleLineEnd : undefined).trim();
                const aboveScramble = input.slice(0, scrambleLineEnd !== -1 ? scrambleLineEnd : input.length).trim();
                const belowScramble = input.slice(index + scrambleLine.length).trim();
                return { aboveScramble, belowScramble };
            } else {
                return { aboveScramble: input.trim(), belowScramble: '' };
            }
        }

        function getLink(scr) {
            const fixed_scr = scr_fix2(scr);
            const { aboveScramble, belowScramble } = splitAtLastScramble(fixed_scr);
            const transformedAbove = replaceCharacters(aboveScramble);
            const transformedBelow = replaceCharacters(belowScramble);
            const URL1 = "https://alg.cubing.net/?setup=" + transformedAbove + "&alg=" + transformedBelow + "%0A&puzzle=3x3x3";
            const URL2 = "https://cubedb.net/?puzzle=3x3&scramble=" + transformedAbove + "&alg=" + transformedBelow + "%0A";
            return { URL1, URL2 };
        }

        const idToKeyMap = {
            'solver': 'solver',
            'scr': 'scramble',
            'rot': 'rot',
            'slot': 'slot',
            'slot2': 'slot2',
            'slot_eo': 'slot3',
            'pair_slot': 'aslot',
            'pslot_edge': 'pse',
            'pslot_corner': 'psc',
            'pslot_edge2': 'pse2',
            'pslot_corner2': 'psc2',
            'pair_pslot_edge': 'apse',
            'pair_pslot_corner': 'apsc',
            'll': 'll',
            'len': 'len',
            'num': 'num',
            'res': 'res',
            'rest': 'rest',
            'mav': 'mav',
            'premove': 'premove',
            'rot_count': 'rc',
            'center_restrict': 'crest',
            'mcv': 'mcv'
        };

        const defaultValues = {
            'F2L': {
                'solver': 'F2L',
                'scr': '',
                'rot': '',
                'slot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'LS': {
                'solver': 'LS',
                'scr': '',
                'rot': '',
                'll': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'LL': {
                'solver': 'LL',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'LU': {
                'solver': 'LU',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'F2L2': {
                'solver': 'F2L2',
                'scr': '',
                'rot': '',
                'slot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'LS2': {
                'solver': 'LS2',
                'scr': '',
                'rot': '',
                'll': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'LL2': {
                'solver': 'LL2',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'LU2': {
                'solver': 'LU2',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'F2L_pair': {
                'solver': 'F2L_pair',
                'scr': '',
                'rot': '',
                'slot2': '',
                'pair_slot': 'BL',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'PF2L': {
                'solver': 'PF2L',
                'scr': '',
                'rot': '',
                'pslot_edge': '',
                'pslot_corner': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'PF2L_pair': {
                'solver': 'PF2L_pair',
                'scr': '',
                'rot': '',
                'pslot_edge2': '',
                'pslot_corner2': '',
                'pair_pslot_edge': 'BL',
                'pair_pslot_corner': 'BL',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            },
            'twophase': {
                'solver': 'twophase',
                'scr': '',
                'rot': ''
            },
            'EOCross': {
                'solver': 'EOCross',
                'scr': '',
                'rot': '',
                'slot_eo': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY',
                'mcv': ''
            }
        };

        const idList = [
            'solver',
            'scr',
            'rot',
            'slot',
            'slot2',
            'slot_eo',
            'pair_slot',
            'pslot_edge',
            'pslot_corner',
            'pslot_edge2',
            'pslot_corner2',
            'pair_pslot_edge',
            'pair_pslot_corner',
            'll',
            'len',
            'num',
            'res',
            'rest',
            'mav',
            'premove',
            'rot_count',
            'center_restrict',
            'mcv'
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const restrictFieldset = document.getElementById('res');
            const tableWrapper = document.getElementById('res_table_wrapper');
            const tableBody = document.querySelector('#res_table tbody');
            const moveAvailableTable = document.getElementById('move_available_table');
            const moveCountTableWrapper = document.getElementById('count_table_wrapper');
            const moveCountTableBody = document.querySelector('#count_table tbody');

            const moveDisplayNames = {
                u: "u", d: "d", l: "l", r: "r", f: "f", b: "b", x: "x", y: "y", z: "z"
            };

            function createMoveRow(move) {
                const displayName = moveDisplayNames[move] || move.toUpperCase();
                const newRow = document.createElement('tr');
                newRow.dataset.move = move;
                let rowHTML = `<th>${displayName}</th>`;
                for (let i = 1; i <= 3; i++) {
                    rowHTML += `<td>
                <input type="checkbox" id="checkbox_restrict${move}${i}" class="custom-checkbox restrict" value="${move}" checked>
                <label for="checkbox_restrict${move}${i}"></label>
            </td>`;
                }
                newRow.innerHTML = rowHTML;
                return newRow;
            }

            function updateRestrictTable() {
                const restrictCheckboxes = restrictFieldset.querySelectorAll('input[type="checkbox"]');
                restrictCheckboxes.forEach(checkbox => {
                    const move = checkbox.value;
                    const existingRow = tableBody.querySelector(`tr[data-move="${move}"]`);
                    if (checkbox.checked) {
                        if (!existingRow) {
                            tableBody.appendChild(createMoveRow(move));
                        }
                    } else {
                        if (existingRow) {
                            existingRow.remove();
                        }
                    }
                });
            }

            function getIdsFromCheckboxes() {
                const resChecked = restrictFieldset.querySelectorAll('input[type="checkbox"]:checked');
                const resId = Array.from(resChecked).map(cb => cb.value).join('');

                const restChecked = tableBody.querySelectorAll('input[type="checkbox"]:checked');
                const restId = Array.from(restChecked).map(cb => {
                    const move = cb.value;
                    const suffix = cb.id.slice(-1);
                    if (suffix === '1') return move;
                    if (suffix === '2') return move + '2';
                    if (suffix === '3') return move + '-';
                }).join('_');

                return [resId, restId];
            }

            function setCheckboxesFromIds([resId, restId]) {
                restrictFieldset.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

                const resMoves = resId.split('');
                resMoves.forEach(move => {
                    const cb = restrictFieldset.querySelector(`input[value="${move}"]`);
                    if (cb) cb.checked = true;
                });

                updateRestrictTable();
                updateMoveCountTable();

                tableBody.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

                const restMoves = restId.split('_');
                restMoves.forEach(restMove => {
                    if (!restMove) return;

                    const move = restMove.charAt(0);
                    const suffix = restMove.slice(1);
                    let idSuffix;

                    if (suffix === '') idSuffix = '1';
                    else if (suffix === '2') idSuffix = '2';
                    else if (suffix === '-') idSuffix = '3';
                    else return;

                    const cb = tableBody.querySelector(`#checkbox_restrict${move}${idSuffix}`);
                    if (cb) cb.checked = true;
                });
                updateMoveAvailableTable();
            }

            function sanitizeMoveForId(moveStr) {
                if (moveStr === '') return 'EMPTY';
                return moveStr.replace(/'/g, '-');
            }

            function updateMoveAvailableTable() {
                const thead = moveAvailableTable.querySelector('thead');
                const tbody = moveAvailableTable.querySelector('tbody');

                const previousStates = new Map();
                moveAvailableTable.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    previousStates.set(cb.id, cb.checked);
                });

                const restChecked = tableWrapper.querySelectorAll('input[type="checkbox"]:checked');
                const headers = Array.from(restChecked).map(cb => {
                    const move = cb.value;
                    const suffix = cb.id.slice(-1);
                    if (suffix === '1') return move;
                    if (suffix === '2') return move + '2';
                    if (suffix === '3') return move + "'";
                    return '';
                }).filter(Boolean);

                const colHeaders = headers;
                const rowHeaders = [...headers, ""];

                thead.innerHTML = '';
                tbody.innerHTML = '';

                const headerRow = document.createElement('tr');
                headerRow.appendChild(document.createElement('th'));
                colHeaders.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                rowHeaders.forEach(rowHeaderText => {
                    const bodyRow = document.createElement('tr');
                    const rowTh = document.createElement('th');
                    rowTh.textContent = rowHeaderText;
                    bodyRow.appendChild(rowTh);

                    const sanitizedRow = sanitizeMoveForId(rowHeaderText);

                    colHeaders.forEach(colHeaderText => {
                        const td = document.createElement('td');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'custom-checkbox restrict';

                        const sanitizedCol = sanitizeMoveForId(colHeaderText);
                        checkbox.id = `checkbox_move_available_${sanitizedRow}_${sanitizedCol}`;

                        const label = document.createElement('label');
                        label.htmlFor = checkbox.id;

                        if (previousStates.has(checkbox.id)) {
                            checkbox.checked = previousStates.get(checkbox.id);
                        } else {
                            checkbox.checked = shouldBeCheckedByDefault(rowHeaderText, colHeaderText);
                        }

                        td.appendChild(checkbox);
                        td.appendChild(label);
                        bodyRow.appendChild(td);
                    });
                    tbody.appendChild(bodyRow);
                });
            }


            function updateMoveCountTable() {
                const checkedMoves = Array.from(restrictFieldset.querySelectorAll('input:checked'), cb => cb.value);
                const existingRows = new Set(Array.from(moveCountTableBody.querySelectorAll('tr'), tr => tr.dataset.move));

                existingRows.forEach(move => {
                    if (!checkedMoves.includes(move)) {
                        moveCountTableBody.querySelector(`tr[data-move="${move}"]`)?.remove();
                    }
                });

                checkedMoves.forEach(move => {
                    if (!existingRows.has(move)) {
                        const newRow = moveCountTableBody.insertRow();
                        newRow.dataset.move = move;
                        newRow.innerHTML = `
                            <th>${move}</th>
                            <td><input type="number" min="0" class="move-count-input" data-move="${move}" value="20"></td>
                            <td><input type="number" min="0" class="move-count-input" data-move="${move}2" value="20"></td>
                            <td><input type="number" min="0" class="move-count-input" data-move="${move}-" value="20"></td>
                        `;
                    }
                });
            }

            function syncAllTables() {
                const checkedResMoves = new Set(Array.from(restrictFieldset.querySelectorAll('input:checked'), cb => cb.value));
                const allCountTableRows = moveCountTableBody.querySelectorAll('tr');

                allCountTableRows.forEach(row => {
                    const move = row.dataset.move;
                    row.style.display = checkedResMoves.has(move) ? '' : 'none';
                });

                moveCountTableBody.querySelectorAll('.move-count-input').forEach(countInput => {
                    const moveStr = countInput.dataset.move;
                    const moveBase = moveStr.charAt(0);

                    const resCheckbox = restrictFieldset.querySelector(`input[value="${moveBase}"]`);
                    if (!resCheckbox || !resCheckbox.checked) {
                        return;
                    }

                    let restCheckboxId;
                    const suffix = moveStr.slice(1);
                    if (suffix === '') restCheckboxId = `checkbox_restrict${moveBase}1`;
                    else if (suffix === '2') restCheckboxId = `checkbox_restrict${moveBase}2`;
                    else if (suffix === '-') restCheckboxId = `checkbox_restrict${moveBase}3`;

                    const restCheckbox = tableBody.querySelector(`#${restCheckboxId}`);

                    if (restCheckbox && restCheckbox.checked) {
                        if ((countInput.disabled && countInput.value === '0') || countInput.value === '') {
                            countInput.value = '20';
                        }
                        countInput.disabled = false;
                    } else {
                        countInput.disabled = true;
                        countInput.value = '0';
                    }
                });
            }

            function getMavString() {
                const overrides = [];
                const table = document.getElementById('move_available_table');
                const rows = table.querySelectorAll('tbody tr');

                rows.forEach(row => {
                    const rowHeaderText = row.querySelector('th').textContent;
                    const checkboxes = row.querySelectorAll('input[type="checkbox"]');

                    checkboxes.forEach((checkbox, colIndex) => {
                        const colHeaderText = table.querySelector(`thead th:nth-child(${colIndex + 2})`).textContent;

                        const isActuallyChecked = checkbox.checked;
                        const isDefaultChecked = shouldBeCheckedByDefault(rowHeaderText, colHeaderText);

                        if (isActuallyChecked !== isDefaultChecked) {
                            const sanitizedRow = sanitizeMoveForId(rowHeaderText);
                            const sanitizedCol = sanitizeMoveForId(colHeaderText);
                            overrides.push(`${sanitizedRow}~${sanitizedCol}`);
                        }
                    });
                });

                return overrides.join('|');
            }

            function setMavFromString(mavString) {
                if (!mavString) return;

                const overrides = mavString.split('|');
                overrides.forEach(override => {
                    const parts = override.split('~');
                    if (parts.length !== 2) return;

                    const [sanitizedRow, sanitizedCol] = parts;
                    const checkboxId = `checkbox_move_available_${sanitizedRow}_${sanitizedCol}`;
                    const checkbox = document.getElementById(checkboxId);

                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                });
            }

            function getCrestString() {
                const checkedItems = [];
                const prefix = "checkbox_center_restrict_";

                const checkboxes = document.querySelectorAll('#center_restrict input[type="checkbox"]:checked');

                checkboxes.forEach(cb => {
                    if (cb.id && cb.id.startsWith(prefix)) {
                        checkedItems.push(cb.id.substring(prefix.length));
                    }
                });

                return checkedItems.join('|');
            }

            function setCrestFromString(crestString) {
                document.querySelectorAll('#center_restrict input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });

                const itemsToCheck = crestString.split('|');
                itemsToCheck.forEach(item => {
                    if (item) {
                        const checkboxId = `checkbox_center_restrict_${item}`;
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox) {
                            checkbox.checked = true;
                        }
                    }
                });
            }

            function getMoveCountString() {
                const params = [];
                document.querySelectorAll('#count_table .move-count-input').forEach(input => {
                    const row = input.closest('tr');
                    if (row.style.display !== 'none' && !input.disabled && input.value && input.value !== "20") {
                        params.push(`${input.dataset.move}:${input.value}`);
                    }
                });
                return params.join('_');
            }

            function setMoveCountFromString(paramString, restId) {
                const activeRestMoves = new Set(restId ? restId.split('_') : []);

                document.querySelectorAll('#count_table .move-count-input').forEach(input => {
                    const move = input.dataset.move;
                    if (activeRestMoves.has(move)) {
                        input.disabled = false;
                        input.value = '20';
                    } else {
                        input.value = '0';
                    }
                });

                if (paramString) {
                    paramString.split('_').forEach(part => {
                        const [moveStr, value] = part.split(':');
                        if (moveStr && value) {
                            const input = moveCountTableBody.querySelector(`.move-count-input[data-move="${moveStr}"]`);
                            if (input) input.value = value;
                        }
                    });
                }
            }

            function initializePage() {

                const allPossibleMoves = Array.from(restrictFieldset.querySelectorAll('input.restrict'), cb => cb.value);
                allPossibleMoves.forEach(move => {
                    const newRow = moveCountTableBody.insertRow();
                    newRow.dataset.move = move;
                    newRow.innerHTML = `
                <th>${move}</th>
                <td><input type="number" min="0" class="move-count-input" data-move="${move}"></td>
                <td><input type="number" min="0" class="move-count-input" data-move="${move}2"></td>
                <td><input type="number" min="0" class="move-count-input" data-move="${move}-"></td>
            `;
                });

                function handleCheckboxChange() {
                    updateRestrictTable();
                    updateMoveCountTable();
                    syncAllTables();
                    updateMoveAvailableTable();
                    updateUrlParams();
                }

                restrictFieldset.addEventListener('change', handleCheckboxChange);
                tableWrapper.addEventListener('change', () => {
                    syncAllTables();
                    updateMoveAvailableTable();
                    updateUrlParams();
                });

                if (moveCountTableWrapper) {
                    moveCountTableWrapper.addEventListener('input', () => { updateUrlParams(); });
                }
            }

            initializePage();


            const faces = ['U', 'L', 'F', 'R', 'B', 'D'];
            const cubeContainer = document.getElementById('cube-container');

            faces.forEach(faceLetter => {
                const faceDiv = document.createElement('div');
                faceDiv.id = `face-${faceLetter}`;
                faceDiv.className = 'face';
                for (let i = 1; i <= 9; i++) {
                    const stickerDiv = document.createElement('div');
                    stickerDiv.id = `sticker-${faceLetter}${i}`;
                    stickerDiv.className = 'sticker';
                    faceDiv.appendChild(stickerDiv);
                }
                cubeContainer.appendChild(faceDiv);
            });

            let state = {
                colors: { U: 'white', R: 'red', F: 'green', D: 'yellow', L: 'orange', B: 'blue' },
                pieces: {},
                mode: 'swap',
                firstSelection: null
            };

            function initializePieces() {
                state.pieces = {
                    ULB: { pos: 'ULB', type: 'corner', faces: ['U1', 'L1', 'B3'], orientation: ['U', 'L', 'B'] },
                    UBR: { pos: 'UBR', type: 'corner', faces: ['U3', 'B1', 'R3'], orientation: ['U', 'B', 'R'] },
                    URF: { pos: 'URF', type: 'corner', faces: ['U9', 'R1', 'F3'], orientation: ['U', 'R', 'F'] },
                    UFL: { pos: 'UFL', type: 'corner', faces: ['U7', 'F1', 'L3'], orientation: ['U', 'F', 'L'] },
                    DLF: { pos: 'DLF', type: 'corner', faces: ['D1', 'L9', 'F7'], orientation: ['D', 'L', 'F'] },
                    DFR: { pos: 'DFR', type: 'corner', faces: ['D3', 'F9', 'R7'], orientation: ['D', 'F', 'R'] },
                    DRB: { pos: 'DRB', type: 'corner', faces: ['D9', 'R9', 'B7'], orientation: ['D', 'R', 'B'] },
                    DBL: { pos: 'DBL', type: 'corner', faces: ['D7', 'B9', 'L7'], orientation: ['D', 'B', 'L'] },
                    UB: { pos: 'UB', type: 'edge', faces: ['U2', 'B2'], orientation: ['U', 'B'] },
                    UR: { pos: 'UR', type: 'edge', faces: ['U6', 'R2'], orientation: ['U', 'R'] },
                    UF: { pos: 'UF', type: 'edge', faces: ['U8', 'F2'], orientation: ['U', 'F'] },
                    UL: { pos: 'UL', type: 'edge', faces: ['U4', 'L2'], orientation: ['U', 'L'] },
                    LF: { pos: 'LF', type: 'edge', faces: ['L6', 'F4'], orientation: ['L', 'F'] },
                    FR: { pos: 'FR', type: 'edge', faces: ['F6', 'R4'], orientation: ['F', 'R'] },
                    RB: { pos: 'RB', type: 'edge', faces: ['R6', 'B4'], orientation: ['R', 'B'] },
                    BL: { pos: 'BL', type: 'edge', faces: ['B6', 'L4'], orientation: ['B', 'L'] },
                    DF: { pos: 'DF', type: 'edge', faces: ['D2', 'F8'], orientation: ['D', 'F'] },
                    DR: { pos: 'DR', type: 'edge', faces: ['D6', 'R8'], orientation: ['D', 'R'] },
                    DB: { pos: 'DB', type: 'edge', faces: ['D8', 'B8'], orientation: ['D', 'B'] },
                    DL: { pos: 'DL', type: 'edge', faces: ['D4', 'L8'], orientation: ['D', 'L'] },
                    U: { pos: 'U', type: 'center', faces: ['U5'], orientation: ['U'] }, L: { pos: 'L', type: 'center', faces: ['L5'], orientation: ['L'] }, F: { pos: 'F', type: 'center', faces: ['F5'], orientation: ['F'] }, R: { pos: 'R', type: 'center', faces: ['R5'], orientation: ['R'] }, B: { pos: 'B', type: 'center', faces: ['B5'], orientation: ['B'] }, D: { pos: 'D', type: 'center', faces: ['D5'], orientation: ['D'] },
                };
            }

            function render() {
                for (const pieceId in state.pieces) {
                    const piece = state.pieces[pieceId];
                    const originalPieceDef = getInitialPieces()[piece.pos];
                    originalPieceDef.faces.forEach((stickerId, index) => {
                        const stickerEl = document.getElementById(`sticker-${stickerId}`);
                        const faceInitial = piece.orientation[index];
                        stickerEl.style.backgroundColor = state.colors[faceInitial];
                    });
                }
            }

            function getPieceByStickerId(stickerId) {
                const initialPieces = getInitialPieces();
                for (const pieceId in initialPieces) {
                    const pieceDef = initialPieces[pieceId];
                    if (pieceDef.faces.includes(stickerId)) {
                        for (const currentPieceId in state.pieces) {
                            if (state.pieces[currentPieceId].pos === pieceDef.pos) {
                                return state.pieces[currentPieceId];
                            }
                        }
                    }
                }
                return null;
            }

            function getOriginalPieceByPos(pos) {
                return getInitialPieces()[pos];
            }

            function getInitialPieces() {
                return {
                    ULB: { pos: 'ULB', type: 'corner', faces: ['U1', 'L1', 'B3'] }, UBR: { pos: 'UBR', type: 'corner', faces: ['U3', 'B1', 'R3'] }, URF: { pos: 'URF', type: 'corner', faces: ['U9', 'R1', 'F3'] }, UFL: { pos: 'UFL', type: 'corner', faces: ['U7', 'F1', 'L3'] }, DLF: { pos: 'DLF', type: 'corner', faces: ['D1', 'L9', 'F7'] }, DFR: { pos: 'DFR', type: 'corner', faces: ['D3', 'F9', 'R7'] }, DRB: { pos: 'DRB', type: 'corner', faces: ['D9', 'R9', 'B7'] }, DBL: { pos: 'DBL', type: 'corner', faces: ['D7', 'B9', 'L7'] },
                    UB: { pos: 'UB', type: 'edge', faces: ['U2', 'B2'] }, UR: { pos: 'UR', type: 'edge', faces: ['U6', 'R2'] }, UF: { pos: 'UF', type: 'edge', faces: ['U8', 'F2'] }, UL: { pos: 'UL', type: 'edge', faces: ['U4', 'L2'] }, LF: { pos: 'LF', type: 'edge', faces: ['L6', 'F4'] }, FR: { pos: 'FR', type: 'edge', faces: ['F6', 'R4'] }, RB: { pos: 'RB', type: 'edge', faces: ['R6', 'B4'] }, BL: { pos: 'BL', type: 'edge', faces: ['B6', 'L4'] }, DF: { pos: 'DF', type: 'edge', faces: ['D2', 'F8'] }, DR: { pos: 'DR', type: 'edge', faces: ['D6', 'R8'] }, DB: { pos: 'DB', type: 'edge', faces: ['D8', 'B8'] }, DL: { pos: 'DL', type: 'edge', faces: ['D4', 'L8'] },
                    U: { pos: 'U', type: 'center', faces: ['U5'] }, L: { pos: 'L', type: 'center', faces: ['L5'] }, F: { pos: 'F', type: 'center', faces: ['F5'] }, R: { pos: 'R', type: 'center', faces: ['R5'] }, B: { pos: 'B', type: 'center', faces: ['B5'] }, D: { pos: 'D', type: 'center', faces: ['D5'] },
                };
            }

            function clearSelection() {
                const selected = document.querySelector('.sticker.selected');
                if (selected) selected.classList.remove('selected');
                state.firstSelection = null;
            }

            function orientPiece(piece, targetFaceInitial, targetIndex) {
                if (piece.type === 'edge') {
                    if (piece.orientation[targetIndex] !== targetFaceInitial) {
                        [piece.orientation[0], piece.orientation[1]] = [piece.orientation[1], piece.orientation[0]];
                    }
                } else if (piece.type === 'corner') {
                    let attempts = 0;
                    while (piece.orientation[targetIndex] !== targetFaceInitial && attempts < 3) {
                        piece.orientation.unshift(piece.orientation.pop());
                        attempts++;
                    }
                }
            }

            function handleIntelligentSwap(selection1, selection2) {
                const { piece: piece1, stickerId: stickerId1 } = selection1;
                const { piece: piece2, stickerId: stickerId2 } = selection2;

                const originalPos1 = piece1.pos;
                const originalPos2 = piece2.pos;
                const originalPieceDefForPos1 = getOriginalPieceByPos(originalPos1);
                const originalPieceDefForPos2 = getOriginalPieceByPos(originalPos2);

                const sourceIndex1 = originalPieceDefForPos1.faces.indexOf(stickerId1);
                const clickedFaceInitial1 = piece1.orientation[sourceIndex1];

                const sourceIndex2 = originalPieceDefForPos2.faces.indexOf(stickerId2);
                const clickedFaceInitial2 = piece2.orientation[sourceIndex2];

                [piece1.pos, piece2.pos] = [originalPos2, originalPos1];

                const targetIndexForPiece1 = originalPieceDefForPos2.faces.indexOf(stickerId2);
                orientPiece(piece1, clickedFaceInitial1, targetIndexForPiece1);

                const targetIndexForPiece2 = originalPieceDefForPos1.faces.indexOf(stickerId1);
                orientPiece(piece2, clickedFaceInitial2, targetIndexForPiece2);

                render();
            }

            function getSolverString() {
                const stickerOrder = ['U1', 'U2', 'U3', 'U4', 'U5', 'U6', 'U7', 'U8', 'U9', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8', 'R9', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'L1', 'L2', 'L3', 'L4', 'L5', 'L6', 'L7', 'L8', 'L9', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9'];
                const currentStickerFaces = {};
                for (const pieceId in state.pieces) {
                    const piece = state.pieces[pieceId];
                    const originalPieceDef = getOriginalPieceByPos(piece.pos);
                    originalPieceDef.faces.forEach((stickerId, index) => {
                        currentStickerFaces[stickerId] = piece.orientation[index];
                    });
                }
                return stickerOrder.map(stickerId => currentStickerFaces[stickerId] || '?').join('');
            }


            function getscr() {
                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    return "";
                }
                if (typeof reverse !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    return "";
                }
                var cube = getSolverString();
                var solution = min2phase.solve(cube);
                if (solution === "") {
                    alert("Already solved.");
                    return "";
                } else if (solution.includes('Error')) {
                    if (solution.includes('6')) {
                        alert("Parity Error.");
                    } else if (solution.includes('3')) {
                        alert("Edge Orientation Error.");
                    } else if (solution.includes('5')) {
                        alert("Corner Orientation Error.");
                    }
                    return "";
                }
                return reverse(solution);
            }

            function resetCubeState() {
                initializePieces();
                render();
                clearSelection();
            }

            document.querySelectorAll('.color-selector').forEach(selector => {
                selector.addEventListener('change', (e) => {
                    const changedFace = e.target.dataset.face;
                    const newColor = e.target.value;
                    const customPicker = document.getElementById(`custom-color-picker-${changedFace}`);

                    state.colors[changedFace] = newColor === 'custom' ? customPicker.value : newColor;

                    document.querySelectorAll('.custom-color-picker').forEach(picker => {
                        const face = picker.dataset.face;
                        const correspondingSelect = document.getElementById(`color-selector-${face}`);
                        if (correspondingSelect.value === 'custom') {
                            picker.classList.remove('hidden');
                        } else {
                            picker.classList.add('hidden');
                        }
                    });

                    render();
                });
            });

            document.querySelectorAll('.custom-color-picker').forEach(picker => {
                picker.addEventListener('input', (e) => {
                    const face = e.target.dataset.face;
                    state.colors[face] = e.target.value;
                    render();
                });
            });

            document.getElementById('swap-mode-btn').addEventListener('click', () => {
                state.mode = 'swap';
                document.getElementById('swap-mode-btn').classList.add('active');
                document.getElementById('flip-mode-btn').classList.remove('active');
                clearSelection();
            });
            document.getElementById('flip-mode-btn').addEventListener('click', () => {
                state.mode = 'flip';
                document.getElementById('flip-mode-btn').classList.add('active');
                document.getElementById('swap-mode-btn').classList.remove('active');
                clearSelection();
            });

            document.getElementById('reset-cube-btn').addEventListener('click', resetCubeState);

            cubeContainer.addEventListener('click', (e) => {
                if (!e.target.classList.contains('sticker')) return;
                const stickerId = e.target.id.replace('sticker-', '');
                const piece = getPieceByStickerId(stickerId);
                if (piece.type === 'center') return;

                if (state.mode === 'swap') {
                    if (!state.firstSelection) {
                        state.firstSelection = { piece, element: e.target, stickerId };
                        e.target.classList.add('selected');
                    } else {
                        const piece1 = state.firstSelection.piece;
                        const piece2 = piece;
                        if (piece1 === piece2 || piece1.type !== piece2.type) {
                            clearSelection();
                            return;
                        }
                        handleIntelligentSwap(state.firstSelection, { piece, stickerId });
                        clearSelection();
                    }
                } else if (state.mode === 'flip') {
                    const orientation = piece.orientation;
                    if (piece.type === 'corner') {
                        orientation.unshift(orientation.pop());
                    } else if (piece.type === 'edge') {
                        [orientation[0], orientation[1]] = [orientation[1], orientation[0]];
                    }
                    render();
                }
            });

            document.getElementById('ui_solve_btn').addEventListener('click', () => {
                const ret = getscr();
                const prerot = document.getElementById('pre_rot').value;
                document.getElementById('scr').value = prerot + " // Pre Rotations\n" + ret.replace(/2'/g, '2').replace(/[\r\n]+$/, '') + " // setup\n";
                save();
            });

            initializePieces();
            render();

            window.getIds = getIdsFromCheckboxes;
            window.setIds = setCheckboxesFromIds;
            window.getMavString = getMavString;
            window.setMavFromString = setMavFromString;
            window.getCrestString = getCrestString;
            window.setCrestFromString = setCrestFromString;
            window.getMoveCountString = getMoveCountString;
            window.setMoveCountFromString = setMoveCountFromString;
            window.initializeDynamicTables = () => {
                updateRestrictTable();
                syncAllTables();
                updateMoveAvailableTable();
            };

        });

        const AXIS_Y = ['U', 'D', 'E', 'u', 'd', 'y'];
        const AXIS_X = ['L', 'R', 'M', 'l', 'r', 'x'];
        const AXIS_Z = ['F', 'B', 'S', 'f', 'b', 'z'];
        const ALL_AXES = [AXIS_Y, AXIS_X, AXIS_Z];

        function getMoveBase(move) {
            if (!move) return '';
            return move.charAt(0);
        }

        function shouldBeCheckedByDefault(prevMove, nextMove) {
            if (!prevMove || !nextMove) {
                return true;
            }

            const prevBase = getMoveBase(prevMove);
            const nextBase = getMoveBase(nextMove);

            if (prevBase === nextBase) {
                return false;
            }

            const axis = ALL_AXES.find(ax => ax.includes(prevBase));
            if (axis && axis.includes(nextBase)) {
                const prevIndex = axis.indexOf(prevBase);
                const nextIndex = axis.indexOf(nextBase);
                if (prevIndex > nextIndex) {
                    return false;
                }
            }

            return true;
        }

        function updateUrlParams() {
            const solver = document.getElementById('solver').value;
            const url = new URL(window.location.href);
            const defaultValueTmp = defaultValues[solver];
            const [resId, restId] = getIds();
            const mavId = getMavString();
            const crestString = getCrestString();
            const mcString = getMoveCountString();
            idList.forEach(id => {
                const key = idToKeyMap[id];
                var newValue = document.getElementById(id)?.value;
                if (typeof key !== "undefined" && typeof defaultValueTmp[id] !== "undefined") {
                    if (id === 'scr' || id === 'premove') {
                        if (newValue !== '') {
                            newValue = encodeURIComponent(scr_fix2(newValue).replace(/ /g, '_').replace(/'/g, '-'));
                            url.searchParams.set(key, newValue);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'res') {
                        const rot_string = resId;
                        if (resId !== defaultValueTmp[id]) {
                            url.searchParams.set(key, rot_string);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'rest') {
                        const rot_string = restId;
                        if (restId !== defaultValueTmp[id]) {
                            url.searchParams.set(key, rot_string);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'mav') {
                        if (mavId) {
                            url.searchParams.set(key, mavId);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === "center_restrict") {
                        if (crestString !== defaultValueTmp[id]) {
                            url.searchParams.set(key, crestString);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'mcv') {
                        if (mcString !== defaultValueTmp[id]) {
                            url.searchParams.set(key, mcString)
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else {
                        if ((document.getElementById(id).tagName === 'SELECT' && document.getElementById(id).selectedIndex > 0) || (document.getElementById(id).tagName === "INPUT" && newValue !== defaultValueTmp[id])) {
                            newValue = newValue.replace(/ /g, '_').replace(/'/g, '-');
                            url.searchParams.set(key, newValue);
                        } else {
                            url.searchParams.delete(key);
                        }
                    }
                } else {
                    url.searchParams.delete(key);
                }
            });
            try {
                window.history.replaceState({}, '', url);
            } catch (e) {
                console.log(e.message);
            }
        }

        function setParamsFromUrl(urlParams) {
            const solver = urlParams.get(idToKeyMap['solver']) ? urlParams.get(idToKeyMap['solver']) : 'F2L';
            document.getElementById('solver').value = solver;
            change();
            document.getElementById('rot').value = urlParams.get(idToKeyMap['rot']) ? urlParams.get(idToKeyMap['rot']).replace(/_/g, ' ').replace(/-/g, '\'') : defaultValues[solver]['rot'];
            if (solver !== "twophase") {
                const premoveParam = urlParams.get(idToKeyMap['premove']);
                if (premoveParam) {
                    document.getElementById('premove').value = decodeURIComponent(premoveParam.replace(/_/g, ' ').replace(/-/g, "'"));
                } else {
                    document.getElementById('premove').value = '';
                }
                document.getElementById('len').value = urlParams.get(idToKeyMap['len']) ? urlParams.get(idToKeyMap['len']) : defaultValues[solver]['len'];
                document.getElementById('num').value = urlParams.get(idToKeyMap['num']) ? urlParams.get(idToKeyMap['num']) : defaultValues[solver]['num'];

                const resParam = urlParams.get(idToKeyMap['res']);
                const restParam = urlParams.get(idToKeyMap['rest']);
                const defaultRes = defaultValues[solver]['res'];
                const defaultRest = defaultValues[solver]['rest'];
                const finalResId = resParam || defaultRes;
                let finalRestId;

                if (restParam) {
                    finalRestId = restParam;
                } else if (resParam) {
                    finalRestId = finalResId.split('').flatMap(move => [move, move + '2', move + '-']).join('_');
                } else {
                    finalRestId = defaultRest;
                }
                setIds([finalResId, finalRestId]);
                const mavString = urlParams.get(idToKeyMap['mav']);
                if (mavString) {
                    setMavFromString(mavString);
                }
                const crestKey = idToKeyMap['center_restrict'];
                const defaultCrest = 'EMPTY_EMPTY';
                const crestParam = urlParams.get(crestKey);

                setCrestFromString(crestParam ?? defaultCrest);
                document.getElementById('rot_count').value = urlParams.get(idToKeyMap['rot_count']) ? urlParams.get(idToKeyMap['rot_count']) : defaultValues[solver]['rot_count'];

                const mcvKey = idToKeyMap['mcv'];
                const defaultMcv = '';
                const mcvParam = urlParams.get(mcvKey);
                setMoveCountFromString(mcvParam ?? defaultMcv, finalRestId);
            }
            if (solver === "F2L" || solver === "F2L2") {
                document.getElementById('slot').value = urlParams.get(idToKeyMap['slot']) ? urlParams.get(idToKeyMap['slot']).replace(/_/g, ' ') : defaultValues[solver]['slot'];
            } else if (solver === "F2L_pair") {
                document.getElementById('slot2').value = urlParams.get(idToKeyMap['slot2']) ? urlParams.get(idToKeyMap['slot2']).replace(/_/g, ' ') : defaultValues[solver]['slot2'];
                updateDropdown2();
                if (urlParams.get(idToKeyMap['pair_slot'])) {
                    document.getElementById('pair_slot').value = urlParams.get(idToKeyMap['pair_slot']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pair_slot').selectedIndex = 0;
                }
            } else if (solver === "LS" || solver === "LS2") {
                document.getElementById('ll').value = urlParams.get(idToKeyMap['ll']) ? urlParams.get(idToKeyMap['ll']).replace(/_/g, ' ') : defaultValues[solver]['ll'];
            } else if (solver === "PF2L") {
                document.getElementById('pslot_edge').value = urlParams.get(idToKeyMap['pslot_edge']) ? urlParams.get(idToKeyMap['pslot_edge']).replace(/_/g, ' ') : defaultValues[solver]['pslot_edge'];
                updateDropdown();
                if (urlParams.get(idToKeyMap['pslot_corner'])) {
                    document.getElementById('pslot_corner').value = urlParams.get(idToKeyMap['pslot_corner']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pslot_corner').selectedIndex = 0;
                }
            } else if (solver === "PF2L_pair") {
                document.getElementById('pslot_edge2').value = urlParams.get(idToKeyMap['pslot_edge2']) ? urlParams.get(idToKeyMap['pslot_edge2']).replace(/_/g, ' ') : defaultValues[solver]['pslot_edge2'];
                updateDropdown3();
                if (urlParams.get(idToKeyMap['pslot_corner2'])) {
                    document.getElementById('pslot_corner2').value = urlParams.get(idToKeyMap['pslot_corner2']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pslot_corner2').selectedIndex = 0;
                }
                if (urlParams.get(idToKeyMap['pair_pslot_edge'])) {
                    document.getElementById('pair_pslot_edge').value = urlParams.get(idToKeyMap['pair_pslot_edge']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pair_pslot_edge').selectedIndex = 0;
                }
                updateDropdown4()
                if (urlParams.get(idToKeyMap['pair_pslot_corner'])) {
                    document.getElementById('pair_pslot_corner').value = urlParams.get(idToKeyMap['pair_pslot_corner']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pair_pslot_corner').selectedIndex = 0;
                }
            } else if (solver === "EOCross") {
                document.getElementById('slot_eo').value = urlParams.get(idToKeyMap['slot_eo']) ? urlParams.get(idToKeyMap['slot_eo']).replace(/_/g, ' ') : defaultValues[solver]['slot_eo'];
            }
            if (typeof window.initializeDynamicTables === 'function') {
                window.initializeDynamicTables();
            }
        }

        function startWorker() {
            try {
                if (worker) {
                    worker.terminate();
                    worker = null;
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.innerHTML = "Search terminated.<br>";
                    element.appendChild(content);
                    document.getElementById("solveButton").textContent = "Start";
                    return;
                }

                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    document.getElementById("solveButton").textContent = "Start";
                    return;
                }
                if (typeof convert !== "function" || typeof generateTwoPhaseInput !== "function" || typeof convertMask !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.innerHTML = "Error: Search terminated due an error.<br>";
                    element.appendChild(content);
                    document.getElementById("solveButton").textContent = "Start";
                    return;
                }
                document.getElementById("countLine").value = 0;
                document.getElementById("currentDepth").value = -1;
                document.getElementById("result").innerHTML = "";
                messageCount = 0;
                const solver = document.getElementById('solver').value;
                const scr_val = document.getElementById("scr").value;
                const scr = scr_fix(scr_val);
                const scr2 = scr_fix2(scr_val);
                if (scr === "") {
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.innerHTML = "Input scramble.<br>";
                    element.appendChild(content);
                    return;
                }
                body = "";
                const rot = document.getElementById('rot').value;
                const slot = document.getElementById('slot').value;
                const slot2 = document.getElementById('slot2').value;
                const slot3 = document.getElementById('slot_eo').value;
                const pair_slot = document.getElementById('pair_slot').value;
                const pslot_e = document.getElementById('pslot_edge').value;
                const pslot_c = document.getElementById('pslot_corner').value;
                const pslot_e2 = document.getElementById('pslot_edge2').value;
                const pslot_c2 = document.getElementById('pslot_corner2').value;
                const pair_pslot_e = document.getElementById('pair_pslot_edge').value;
                const pair_pslot_c = document.getElementById('pair_pslot_corner').value;
                const ll = document.getElementById('ll').value
                const num = document.getElementById('num').value;
                const len = document.getElementById('len').value;
                const restrict = getIds()[1];
                const premove = scr_fix(document.getElementById('premove').value);
                const ma = getMavString();
                const center_offset = getCrestString();
                const max_rot_count = document.getElementById('rot_count').value;
                const mc = getMoveCountString();
                document.getElementById("solveButton").textContent = "End";
                const convertResult = convert(scr);
                const result_moves = convertResult[0];
                const result_rotation = convertResult[1] + " " + rot;
                if (AutoMaskSetting) {
                    setStickeringOptionAuto();
                } else {
                    setMaskTmp();
                }
                const mask_input = getMaskInputs();
                const convertedMask = convertMask(mask_input.maskInputCenter, mask_input.maskInputEdges, mask_input.maskInputCorners, result_rotation);
                setMask(convertedMask);

                if (solver === "F2L" || solver === "LS" || solver === "LL" || solver == "LU") {
                    const args = { solver: solver, scr: result_moves, rot: rot, slot: slot, ll: ll, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma, mcString: mc };
                    worker = new Worker('src/crossSolver/worker.js');
                    worker.postMessage(args);
                } else if (solver === "F2L2" || solver === "LS2" || solver === "LL2" || solver == "LU2") {
                    const args = { solver: solver, scr: result_moves, rot: rot, slot: slot, ll: ll, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma, mcString: mc };
                    worker = new Worker('src/highMemorySolver/worker2.js');
                    worker.postMessage(args);
                } else if (solver === "PF2L") {
                    const args = { scr: result_moves, rot: rot, slot: pslot_e, pslot: pslot_c, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma, mcString: mc };
                    worker = new Worker('src/pseudoCrossSolver/worker3.js');
                    worker.postMessage(args);
                } else if (solver === "F2L_pair") {
                    const args = { scr: result_moves, rot: rot, slot: slot2, pslot: pair_slot, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma, mcString: mc };
                    worker = new Worker('src/F2L_PairingSolver/worker_pairing.js');
                    worker.postMessage(args);
                } else if (solver === "PF2L_pair") {
                    const args = { scr: result_moves, rot: rot, slot: pslot_e2, pslot: pslot_c2, a_slot: pair_pslot_e, a_pslot: pair_pslot_c, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma, mcString: mc };
                    worker = new Worker('src/pseudoPairingSolver/workerPseudoPairing.js');
                    worker.postMessage(args);
                } else if (solver === "twophase") {
                    const sol = min2phase.solve(generateTwoPhaseInput(convert(scr + " " + rot)[0]));
                    appendSol(scr2, rot + " " + sol);
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.textContent = "Search terminated.";
                    element.appendChild(content);
                    document.getElementById("solveButton").textContent = "Start";
                } else if (solver === "EOCross") {
                    const args = { scr: result_moves, rot: rot, slot: slot3, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma, mcString: mc };
                    worker = new Worker("src/EOCrossSolver/worker.js");
                    worker.postMessage(args);
                }
                if (worker) {
                    worker.onmessage = function (event) {
                        appendSol(scr2, event.data);
                    };
                }
            } catch (e) {
                console.log(e.message);
                if (worker) {
                    worker.terminate();
                }
                worker = null;
                const element = document.getElementById('result');
                const content = document.createElement('a');
                content.innerHTML = "Error: Search terminated due an error.<br>";
                element.appendChild(content);
                document.getElementById("solveButton").textContent = "Start";
                return;
            }
        }

        function appendSol(scr, sol) {
            const regex = /^depth\s*=\s*(\d+)/;
            const match = sol.trim().match(regex);
            const element = document.getElementById('result');
            if (sol == "Search finished." || sol == "Already solved." || sol == "Error" || sol == "Unsolvable.") {
                if (worker) {
                    worker.terminate();
                }
                worker = null;
                const element = document.getElementById('result');
                const content = document.createElement('a');
                if (sol == "Error") {
                    content.innerHTML = "Error: Search terminated due to an error.<br>";
                } else if (sol === "Already solved.") {
                    content.innerHTML = "Already solved.<br>";
                } else if (sol === "Search finished.") {
                    content.innerHTML = "Search finished.<br>";
                } else {
                    content.innerHTML = "Unsolvable.<br>";
                }
                element.appendChild(content);
                document.getElementById("solveButton").textContent = "Start";
                return;
            } else if (match && match[1]) {
                const depthNumber = match[1];
                document.getElementById('currentDepth').value = depthNumber;
                return;
            } else {
                messageCount++;
                const details = document.createElement('details');
                if (messageCount === 1 || sol_input) {
                    details.setAttribute('open', '');
                }
                body += messageCount + ": " + sol + "\n";
                const summary = document.createElement('summary');
                summary.textContent = messageCount + ": " + sol;
                summary.setAttribute('translate', 'no');
                const textNode = document.createTextNode(messageCount + ": " + sol);
                const button = document.createElement('button');
                button.classList.add('button', 'medium');
                button.textContent = 'Add';
                button.onclick = function () {
                    add(sol);
                };
                details.appendChild(button);
                var spaceElement3 = document.createElement('a');
                spaceElement3.innerHTML = "&nbsp;";
                details.appendChild(spaceElement3);
                const button2 = document.createElement('button');
                button2.classList.add('button', 'medium');
                button2.textContent = 'Copy';
                button2.onclick = function () {
                    navigator.clipboard.writeText(sol);
                };
                details.appendChild(button2);
                details.appendChild(summary);
                try {
                    const sim = createPlayer(scr, sol);
                    sim.experimentalStickeringMaskOrbits = mask;
                    details.appendChild(sim);
                } catch (e) {
                    if (messageCount === 1) {
                        const lineBreak = document.createElement('br');
                        details.appendChild(lineBreak);
                        const content = document.createElement('a');
                        content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                        details.appendChild(content);
                    }
                }
                const gap = document.createElement('div');
                gap.style.height = '12px';
                details.appendChild(gap);
                const { URL1: link1, URL2: link2 } = getLink(scr + "\n" + sol);
                var link_element1 = document.createElement('a');
                link_element1.href = link1;
                link_element1.target = '_blank';
                link_element1.rel = 'noopener noreferrer';
                link_element1.textContent = 'alg.cubing.net';
                link_element1.setAttribute('translate', 'no');
                details.appendChild(link_element1);
                var spaceElement = document.createElement('a');
                spaceElement.innerHTML = "&nbsp;";
                details.appendChild(spaceElement);
                var link_element2 = document.createElement('a');
                link_element2.href = link2;
                link_element2.target = '_blank';
                link_element2.rel = 'noopener noreferrer';
                link_element2.textContent = 'cubedb.net';
                link_element2.setAttribute('translate', 'no');
                details.appendChild(link_element2);
                var spaceElement2 = document.createElement('a');
                spaceElement2.innerHTML = "&nbsp;";
                details.appendChild(spaceElement2);
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.set('index', `${messageCount}`);
                currentUrl.searchParams.set('sol', sol.replace(/ /g, '_').replace(/'/g, '-'));
                var link_element3 = document.createElement('a');
                link_element3.href = currentUrl;
                link_element3.target = '_blank';
                link_element3.rel = 'noopener noreferrer';
                link_element3.textContent = 'or18.github.io';
                link_element3.setAttribute('translate', 'no');
                details.appendChild(link_element3);
                element.appendChild(details);
                document.getElementById("countLine").value = messageCount;
                if (messageCount === 1) {
                    try {
                        window.history.replaceState({}, '', currentUrl);
                    } catch (e) {
                        console.log(e.message);
                    }
                }
            }
        }

        function change() {
            const selectedValue = document.getElementById("solver").value;
            document.getElementById("basic input").classList.remove("hidden");
            document.getElementById("tp_alert").classList.add("hidden");
            document.getElementById("option_for_F2L").classList.add("hidden");
            document.getElementById("option_for_F2L2").classList.add("hidden");
            document.getElementById("option_for_LS").classList.add("hidden");
            document.getElementById("analyze").classList.add("hidden");
            document.getElementById("eo_analyze").classList.add("hidden");
            document.getElementById("panalyze").classList.add("hidden");
            document.getElementById("option_for_PF2L").classList.add("hidden");
            document.getElementById("option_for_PF2L2").classList.add("hidden");
            document.getElementById("option_for_pair_F2L").classList.add("hidden");
            document.getElementById("option_for_pair_PF2L").classList.add("hidden");
            document.getElementById("pair_analyze").classList.add("hidden");
            document.getElementById("pair_panalyze").classList.add("hidden");
            document.getElementById("tp_alert").classList.add("hidden");
            document.getElementById('option_for_eocross').classList.add("hidden");
            if (selectedValue === "F2L" || selectedValue === "F2L2") {
                document.getElementById("option_for_F2L").classList.remove("hidden");
                document.getElementById("analyze").classList.remove("hidden");
            } else if (selectedValue === "LS" || selectedValue === "LS2") {
                document.getElementById("option_for_LS").classList.remove("hidden");
            } else if (selectedValue === "PF2L") {
                document.getElementById("option_for_PF2L").classList.remove("hidden");
                document.getElementById("panalyze").classList.remove("hidden");
            } else if (selectedValue === "F2L_pair") {
                document.getElementById("option_for_F2L2").classList.remove("hidden");
                document.getElementById("option_for_pair_F2L").classList.remove("hidden");
                document.getElementById("pair_analyze").classList.remove("hidden");
            } else if (selectedValue === "PF2L_pair") {
                document.getElementById("option_for_PF2L2").classList.remove("hidden");
                document.getElementById("option_for_pair_PF2L").classList.remove("hidden");
                document.getElementById("pair_panalyze").classList.remove("hidden");
            } else if (selectedValue === "twophase") {
                document.getElementById("tp_alert").classList.remove("hidden");
                document.getElementById("basic input").classList.add("hidden");
            } else if (selectedValue === "EOCross") {
                document.getElementById('option_for_eocross').classList.remove("hidden");
                document.getElementById("eo_analyze").classList.remove("hidden");
            }
        }

        const textarea = document.getElementById('scr');
        const undoButton = document.getElementById('undo');
        const redoButton = document.getElementById('redo');
        let history_input = [];
        let currentIndex = -1;

        function save() {
            if (currentIndex < history_input.length - 1) {
                history_input = history_input.slice(0, currentIndex + 1);
            }
            history_input.push(textarea.value);
            currentIndex++;
            updateButtons();
            try {
                document.getElementById('show').innerHTML = '';
                const sim = createPlayer(scr_fix2(textarea.value), '');
                sim.controlPanel = "none";
                document.getElementById('show').appendChild(sim);
            } catch (e) {
                const content = document.createElement('a');
                content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                document.getElementById('show').appendChild(content);
            }
        }

        function generateTwoPhaseInputWrapper(scr) {
            if (!isFunctionsReady) {
                alert("The module is still initializing. Please try again in a moment.");
                return;
            }
            if (typeof generateTwoPhaseInput !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            } else {
                return generateTwoPhaseInput(scr);
            }
        }

        function genscr() {
            var cube = min2phase.randomCube();
            var solution = min2phase.solve(cube);
            var sol_reversed = min2phase.solve(generateTwoPhaseInputWrapper(solution));
            document.getElementById('scr').value = scr_fix2(sol_reversed) + " // setup\n";
            save();
        }

        function analyze() {
            try {
                if (worker2) {
                    worker2.terminate();
                    worker2 = null;
                    document.getElementById("analyzer").textContent = "Analyze";
                    if (messageCount_analyzer > 0) {
                        option_table = {
                            valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_table = new List('table', option_table);
                    }
                    return;
                }

                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    document.getElementById("analyzer").textContent = "Analyze";
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("analyzer").textContent = "Analyze";
                    const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                    document.getElementById('table').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('table').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('analyzer_option').value;
                const checkboxes = document.querySelectorAll('#analyzer_rotation_option .analyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("analyzer_num").value;
                messageCount_analyzer = -2;
                document.getElementById('table').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_analyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_analyzer_max';
                input2.readOnly = true;
                document.getElementById('table').appendChild(input);
                document.getElementById('table').innerHTML += "<a>/</a>";
                document.getElementById('table').appendChild(input2);
                worker2 = new Worker('src/crossAnalyzer/worker_analyzer.js');
                document.getElementById("analyzer").textContent = "End";
                worker2.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker2) {
                            worker2.terminate();
                        }
                        worker2 = null;
                        document.getElementById("analyzer").textContent = "Analyze";
                        if (messageCount_analyzer > 0) {
                            option_table = {
                                valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_table = new List('table', option_table);
                        }
                        const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                        document.getElementById('table').innerHTML += error_message;
                        return;
                    } else if (messageCount_analyzer === -2) {
                        messageCount_analyzer++;
                        document.getElementById('table').innerHTML += event.data;
                    } else if (messageCount_analyzer === -1) {
                        messageCount_analyzer++;
                        document.getElementById("count_analyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker2) {
                            worker2.terminate();
                            worker2 = null;
                            document.getElementById("analyzer").textContent = "Analyze";
                            option_table = {
                                valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_table = new List('table', option_table);
                            return;
                        }
                    } else {
                        messageCount_analyzer++;
                        document.querySelector('#analyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_analyzer").value = messageCount_analyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker2.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker2) {
                    worker2.terminate();
                }
                worker2 = null;
                document.getElementById("analyzer").textContent = "Analyze";
                if (messageCount_analyzer > 0) {
                    option_table = {
                        valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_table = new List('table', option_table);
                }
                const error_message = "<br><a>AError: nalyzer terminated due to an error.</a><br>";
                document.getElementById('table').innerHTML += error_message;
                return;
            }
        }

        function initializeForAnalyzer(defaults) {
            setIds([defaults.res, defaults.rest]);
            setMavFromString(defaults.mav);
            setCrestFromString(defaults.center_restrict);
            setMoveCountFromString(defaults.mcv, defaults.rest);
        }

        function solve(slot_option, rotation_option) {
            document.getElementById("solver").value = "F2L";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('slot').value = slot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['F2L']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function reverseScramble() {
            if (!isFunctionsReady) {
                alert("The module is still initializing. Please try again in a moment.");
                return;
            }
            if (typeof reverse !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            }
            const scr_val = document.getElementById("scr").value;
            const scr = scr_fix2(scr_val);
            if (scr === "") {
                return;
            }
            document.getElementById("scr").value = reverse(scr);
            save();
        }

        function mirrorScramble() {
            if (!isFunctionsReady) {
                alert("The module is still initializing. Please try again in a moment.");
                return;
            }
            if (typeof mirror !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            }
            const scr_val = document.getElementById("scr").value;
            const scr = scr_fix2(scr_val);
            if (scr === "") {
                return;
            }
            document.getElementById("scr").value = mirror(scr);
            save();
        }

        function undo() {
            if (currentIndex > 0) {
                currentIndex--;
                textarea.value = history_input[currentIndex];
                updateButtons();
                try {
                    document.getElementById('show').innerHTML = '';
                    const sim = createPlayer(scr_fix2(textarea.value), '');
                    sim.controlPanel = "none";
                    document.getElementById('show').appendChild(sim);
                } catch (e) {
                    const content = document.createElement('a');
                    content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                    document.getElementById('show').appendChild(content);
                }
            }
        }

        function redo() {
            if (currentIndex < history_input.length - 1) {
                currentIndex++;
                textarea.value = history_input[currentIndex];
                updateButtons();
                try {
                    document.getElementById('show').innerHTML = '';
                    const sim = createPlayer(scr_fix2(textarea.value), '');
                    sim.controlPanel = "none";
                    document.getElementById('show').appendChild(sim);
                } catch (e) {
                    const content = document.createElement('a');
                    content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                    document.getElementById('show').appendChild(content);
                }
            }
        }

        function updateButtons() {
            undoButton.disabled = currentIndex <= 0;
            redoButton.disabled = currentIndex >= history_input.length - 1;
            const currentScr = document.getElementById("scr").value;
            if (currentScr === "") {
                document.getElementById("reverse").classList.add("hidden");
                document.getElementById("mirror").classList.add("hidden");
            } else {
                document.getElementById("reverse").classList.remove("hidden");
                document.getElementById("mirror").classList.remove("hidden");
            }
            updateUrlParams();
            if (currentIndex <= 0) {
                undoButton.classList.add("hidden_small");
            } else {
                undoButton.classList.remove("hidden_small");
            }
            if (currentIndex >= history_input.length - 1) {
                redoButton.classList.add("hidden_small")
            } else {
                redoButton.classList.remove("hidden_small");
            }
            if (currentIndex >= 0) {
                const { URL1: link1, URL2: link2 } = getLink(currentScr);
                document.getElementById("link_alg_cubing").href = link1;
                document.getElementById("link_cubedb").href = link2;
                document.getElementById("links").classList.remove("hidden");
            }
        }

        let currentDropdownBOptions = [];
        let currentDropdownPairSlotOptions = [];
        let currentDropdownCorner2Options = [];
        let currentDropdownPairEdgeOptions = [];
        let currentDropdownPairCornerOptions = [];

        function areOptionArraysEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            return arr1.every((option, index) =>
                option.value === arr2[index].value && option.text === arr2[index].text
            );
        }

        function getOptionsForCorner(selectedValue) {
            if (selectedValue === "") return [{ value: "", text: "" }];
            if (["BL", "BR", "FR", "FL"].includes(selectedValue)) {
                return [{ value: "BL", text: "BL" }, { value: "BR", text: "BR" }, { value: "FR", text: "FR" }, { value: "FL", text: "FL" }];
            }
            if (["BL BR", "BL FR", "BL FL", "BR FR", "BR FL", "FR FL"].includes(selectedValue)) {
                return [{ value: "BL BR", text: "BL BR" }, { value: "BL FR", text: "BL FR" }, { value: "BL FL", text: "BL FL" }, { value: "BR FR", text: "BR FR" }, { value: "BR FL", text: "BR FL" }, { value: "FR FL", text: "FR FL" }];
            }
            if (["BL BR FR", "BL BR FL", "BL FR FL", "BR FR FL"].includes(selectedValue)) {
                return [{ value: "BL BR FR", text: "BL BR FR" }, { value: "BL BR FL", text: "BL BR FL" }, { value: "BL FR FL", text: "BL FR FL" }, { value: "BR FR FL", text: "BR FR FL" }];
            }
            return [];
        }

        function getFilteredOptions(selectedValue) {
            const allOptions = [{ value: "BL", text: "BL" }, { value: "BR", text: "BR" }, { value: "FR", text: "FR" }, { value: "FL", text: "FL" }];
            const selectedValueArray = selectedValue.split(" ");
            return allOptions.filter(option => !selectedValueArray.includes(option.value));
        }

        function updateDropdown() {
            const dropdownA = document.getElementById("pslot_edge");
            const dropdownB = document.getElementById("pslot_corner");
            const optionForPF2LC = document.getElementById("option_for_PF2LC");
            const selectedValue = dropdownA.value;
            const newOptions = getOptionsForCorner(selectedValue);
            if (areOptionArraysEqual(currentDropdownBOptions, newOptions)) return;
            const currentlySelectedB = dropdownB.value;
            dropdownB.innerHTML = "";
            newOptions.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });
            currentDropdownBOptions = newOptions;
            if (newOptions.some(option => option.value === currentlySelectedB)) {
                dropdownB.value = currentlySelectedB;
            }
            if (selectedValue !== "") {
                optionForPF2LC.classList.remove("hidden");
            } else {
                optionForPF2LC.classList.add("hidden");
            }
        }

        function updateDropdown2() {
            const dropdownA = document.getElementById("slot2");
            const dropdownB = document.getElementById("pair_slot");
            const selectedValueA = dropdownA.value;
            const newOptions = getFilteredOptions(selectedValueA);
            if (areOptionArraysEqual(currentDropdownPairSlotOptions, newOptions)) return;
            const previousSelectionB = dropdownB.value;
            dropdownB.innerHTML = "";
            newOptions.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });
            currentDropdownPairSlotOptions = newOptions;
            if (newOptions.some(option => option.value === previousSelectionB)) {
                dropdownB.value = previousSelectionB;
            }
        }

        function updateDropdown3() {
            const dropdownA = document.getElementById("pslot_edge2");
            const dropdownB = document.getElementById("pslot_corner2");
            const dropdownC = document.getElementById("pair_pslot_edge");
            const optionForPF2LC2 = document.getElementById("option_for_PF2LC2");
            const selectedValueA = dropdownA.value;

            const newOptionsB = getOptionsForCorner(selectedValueA);
            if (!areOptionArraysEqual(currentDropdownCorner2Options, newOptionsB)) {
                const previousSelectionB = dropdownB.value;
                dropdownB.innerHTML = "";
                newOptionsB.forEach(opt => {
                    const newOpt = document.createElement("option");
                    newOpt.value = opt.value; newOpt.textContent = opt.text;
                    dropdownB.appendChild(newOpt);
                });
                currentDropdownCorner2Options = newOptionsB;
                if (newOptionsB.some(opt => opt.value === previousSelectionB)) {
                    dropdownB.value = previousSelectionB;
                }
            }

            const newOptionsC = getFilteredOptions(selectedValueA);
            if (!areOptionArraysEqual(currentDropdownPairEdgeOptions, newOptionsC)) {
                const previousSelectionC = dropdownC.value;
                dropdownC.innerHTML = "";
                newOptionsC.forEach(opt => {
                    const newOpt = document.createElement("option");
                    newOpt.value = opt.value; newOpt.textContent = opt.text;
                    dropdownC.appendChild(newOpt);
                });
                currentDropdownPairEdgeOptions = newOptionsC;
                if (newOptionsC.some(opt => opt.value === previousSelectionC)) {
                    dropdownC.value = previousSelectionC;
                }
            }

            if (selectedValueA !== "") {
                optionForPF2LC2.classList.remove("hidden");
            } else {
                optionForPF2LC2.classList.add("hidden");
            }

            updateDropdown4();
        }

        function updateDropdown4() {
            const dropdownA = document.getElementById("pslot_corner2");
            const dropdownB = document.getElementById("pair_pslot_corner");
            const selectedValueA = dropdownA.value;

            const newOptions = getFilteredOptions(selectedValueA);

            if (areOptionArraysEqual(currentDropdownPairCornerOptions, newOptions)) {
                return;
            }

            const previousSelectionB = dropdownB.value;
            dropdownB.innerHTML = "";
            newOptions.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });

            currentDropdownPairCornerOptions = newOptions;

            if (newOptions.some(option => option.value === previousSelectionB)) {
                dropdownB.value = previousSelectionB;
            }
        }

        function panalyze() {
            try {
                if (worker3) {
                    worker3.terminate();
                    worker3 = null;
                    document.getElementById("panalyzer").textContent = "Analyze";
                    if (messageCount_panalyzer > 0) {
                        option_ptable = {
                            valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_ptable = new List('ptable', option_ptable);
                    }
                    return;
                }
                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    document.getElementById("panalyzer").textContent = "Analyze";
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("panalyzer").textContent = "Analyze";
                    const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                    document.getElementById('ptable').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('ptable').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('panalyzer_option').value;
                const checkboxes = document.querySelectorAll('#panalyzer_rotation_option .panalyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("panalyzer_num").value;
                messageCount_panalyzer = -2;
                document.getElementById('ptable').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_panalyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_panalyzer_max';
                input2.readOnly = true;
                document.getElementById('ptable').appendChild(input);
                document.getElementById('ptable').innerHTML += "<a>/</a>";
                document.getElementById('ptable').appendChild(input2);
                worker3 = new Worker('src/pseudoCrossAnalyzer/worker_panalyzer.js');
                document.getElementById("panalyzer").textContent = "End";
                worker3.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker3) {
                            worker3.terminate();
                        }
                        worker3 = null;
                        document.getElementById("panalyzer").textContent = "Analyze";
                        if (messageCount_panalyzer > 0) {
                            option_ptable = {
                                valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_ptable = new List('ptable', option_ptable);
                        }
                        const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                        document.getElementById('ptable').innerHTML += error_message;
                        return;
                    } else if (messageCount_panalyzer === -2) {
                        messageCount_panalyzer++;
                        document.getElementById('ptable').innerHTML += event.data;
                    } else if (messageCount_panalyzer === -1) {
                        messageCount_panalyzer++;
                        document.getElementById("count_panalyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker3) {
                            worker3.terminate();
                            worker3 = null;
                            document.getElementById("panalyzer").textContent = "Analyze";
                            option_ptable = {
                                valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_ptable = new List('ptable', option_ptable);
                            return;
                        }
                    } else {
                        messageCount_panalyzer++;
                        document.querySelector('#panalyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_panalyzer").value = messageCount_panalyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker3.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker3) {
                    worker3.terminate();
                }
                worker3 = null;
                document.getElementById("panalyzer").textContent = "Analyze";
                if (messageCount_panalyzer > 0) {
                    option_ptable = {
                        valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_ptable = new List('ptable', option_ptable);
                }
                const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                document.getElementById('ptable').innerHTML += error_message;
                return;
            }
        }

        function psolve(slot_option, pslot_option, rotation_option) {
            document.getElementById("solver").value = "PF2L";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('pslot_edge').value = slot_option;
            updateDropdown();
            document.getElementById('pslot_corner').value = pslot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['PF2L']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function pair_analyze() {
            try {
                if (worker4) {
                    worker4.terminate();
                    worker4 = null;
                    document.getElementById("pair_analyzer").textContent = "Analyze";
                    if (messageCount_pair_analyzer > 0) {
                        option_pair_table = {
                            valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_pair_table = new List('pair_table', option_pair_table);
                    }
                    return;
                }
                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    document.getElementById("pair_analyzer").textContent = "Analyze";
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("pair_analyzer").textContent = "Analyze";
                    const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                    document.getElementById('pair_table').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('pair_table').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('pair_analyzer_option').value;
                const checkboxes = document.querySelectorAll('#pair_analyzer_rotation_option .pair_analyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("pair_analyzer_num").value;
                messageCount_pair_analyzer = -2;
                document.getElementById('pair_table').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_pair_analyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_pair_analyzer_max';
                input2.readOnly = true;
                document.getElementById('pair_table').appendChild(input);
                document.getElementById('pair_table').innerHTML += "<a>/</a>";
                document.getElementById('pair_table').appendChild(input2);
                worker4 = new Worker('src/pairAnalyzer/worker_analyzer.js');
                document.getElementById("pair_analyzer").textContent = "End";
                worker4.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker4) {
                            worker4.terminate();
                        }
                        worker4 = null;
                        document.getElementById("pair_analyzer").textContent = "Analyze";
                        const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                        document.getElementById('pair_table').innerHTML += error_message;
                        return;
                    } else if (messageCount_pair_analyzer === -2) {
                        messageCount_pair_analyzer++;
                        document.getElementById('pair_table').innerHTML += event.data;
                    } else if (messageCount_pair_analyzer === -1) {
                        messageCount_pair_analyzer++;
                        document.getElementById("count_pair_analyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker4) {
                            worker4.terminate();
                            worker4 = null;
                            document.getElementById("pair_analyzer").textContent = "Analyze";
                            if (messageCount_pair_analyzer > 0) {
                                option_pair_table = {
                                    valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                                };
                                list_pair_table = new List('pair_table', option_pair_table);
                            }
                            return;
                        }
                    } else {
                        messageCount_pair_analyzer++;
                        document.querySelector('#pair_analyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_pair_analyzer").value = messageCount_pair_analyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker4.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker4) {
                    worker4.terminate();
                }
                worker4 = null;
                document.getElementById("pair_analyzer").textContent = "Analyze";
                if (messageCount_pair_analyzer > 0) {
                    option_pair_table = {
                        valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_pair_table = new List('pair_table', option_pair_table);
                }
                const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                document.getElementById('pair_table').innerHTML += error_message;
                return;
            }
        }

        function pair_solve(slot_option, pslot_option, rotation_option) {
            document.getElementById("solver").value = "F2L_pair";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('slot2').value = slot_option;
            updateDropdown2();
            document.getElementById('pair_slot').value = pslot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['F2L_pair']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function pair_panalyze() {
            try {
                if (worker5) {
                    worker5.terminate();
                    worker5 = null;
                    document.getElementById("pair_panalyzer").textContent = "Analyze";
                    if (messageCount_pair_panalyzer > 0) {
                        option_pair_ptable = {
                            valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                    }
                    return;
                }
                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    document.getElementById("pair_panalyzer").textContent = "Analyze";
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("pair_panalyzer").textContent = "Analyze";
                    const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                    document.getElementById('pair_ptable').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('pair_ptable').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('pair_panalyzer_option').value;
                const checkboxes = document.querySelectorAll('#pair_panalyzer_rotation_option .pair_panalyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("pair_panalyzer_num").value;
                messageCount_pair_panalyzer = -2;
                document.getElementById('pair_ptable').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_pair_panalyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_pair_panalyzer_max';
                input2.readOnly = true;
                document.getElementById('pair_ptable').appendChild(input);
                document.getElementById('pair_ptable').innerHTML += "<a>/</a>";
                document.getElementById('pair_ptable').appendChild(input2);
                worker5 = new Worker('src/pseudoPairAnalyzer/worker_analyzer.js');
                document.getElementById("pair_panalyzer").textContent = "End";
                worker5.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker5) {
                            worker5.terminate();
                        }
                        worker5 = null;
                        document.getElementById("pair_panalyzer").textContent = "Analyze";
                        if (messageCount_pair_panalyzer > 0) {
                            option_pair_ptable = {
                                valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                        }
                        const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                        document.getElementById('pair_ptable').innerHTML += error_message;
                        return;
                    } else if (messageCount_pair_panalyzer === -2) {
                        messageCount_pair_panalyzer++;
                        document.getElementById('pair_ptable').innerHTML += event.data;
                    } else if (messageCount_pair_panalyzer === -1) {
                        messageCount_pair_panalyzer++;
                        document.getElementById("count_pair_panalyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker5) {
                            worker5.terminate();
                            worker5 = null;
                            document.getElementById("pair_panalyzer").textContent = "Analyze";
                            option_pair_ptable = {
                                valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                            return;
                        }
                    } else {
                        messageCount_pair_panalyzer++;
                        document.querySelector('#pair_panalyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_pair_panalyzer").value = messageCount_pair_panalyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker5.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker5) {
                    worker5.terminate();
                }
                worker5 = null;
                document.getElementById("pair_panalyzer").textContent = "Analyze";
                if (messageCount_pair_panalyzer > 0) {
                    option_pair_ptable = {
                        valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                }
                const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                document.getElementById('pair_ptable').innerHTML += error_message;
                return;
            }
        }

        function pair_psolve(slot_option, pslot_option, a_slot_option, a_pslot_option, rotation_option) {
            document.getElementById("solver").value = "PF2L_pair";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('pslot_edge2').value = slot_option;
            updateDropdown3();
            document.getElementById('pslot_corner2').value = pslot_option;
            updateDropdown4();
            document.getElementById('pair_pslot_edge').value = a_slot_option;
            document.getElementById('pair_pslot_corner').value = a_pslot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['PF2L_pair']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function eo_analyze() {
            try {
                if (worker6) {
                    worker6.terminate();
                    worker6 = null;
                    document.getElementById("eo_analyzer").textContent = "Analyze";
                    if (messageCount_eo_analyzer > 0) {
                        option_eo_table = {
                            valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                        };
                        list_eo_table = new List('eo_table', option_eo_table);
                    }
                    return;
                }

                if (!isFunctionsReady) {
                    alert("The module is still initializing. Please try again in a moment.");
                    document.getElementById("eo_analyzer").textContent = "Analyze";
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("eo_analyzer").textContent = "Analyze";
                    const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                    document.getElementById('eo_table').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('eo_table').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('eo_analyzer_option').value;
                const checkboxes = document.querySelectorAll('#eo_analyzer_rotation_option .eo_analyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("eo_analyzer_num").value;
                messageCount_eo_analyzer = -2;
                document.getElementById('eo_table').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_eo_analyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_eo_analyzer_max';
                input2.readOnly = true;
                document.getElementById('eo_table').appendChild(input);
                document.getElementById('eo_table').innerHTML += "<a>/</a>";
                document.getElementById('eo_table').appendChild(input2);
                worker6 = new Worker('src/EOCrossAnalyzer/worker_analyzer.js');
                document.getElementById("eo_analyzer").textContent = "End";
                worker6.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker6) {
                            worker6.terminate();
                        }
                        worker6 = null;
                        document.getElementById("eo_analyzer").textContent = "Analyze";
                        if (messageCount_eo_analyzer > 0) {
                            option_eo_table = {
                                valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                            };
                            list_eo_table = new List('eo_table', option_eo_table);
                        }
                        const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                        document.getElementById('eo_table').innerHTML += error_message;
                        return;
                    } else if (messageCount_eo_analyzer === -2) {
                        messageCount_eo_analyzer++;
                        document.getElementById('eo_table').innerHTML += event.data;
                    } else if (messageCount_eo_analyzer === -1) {
                        messageCount_eo_analyzer++;
                        document.getElementById("count_eo_analyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker6) {
                            worker6.terminate();
                            worker6 = null;
                            document.getElementById("eo_analyzer").textContent = "Analyze";
                            option_eo_table = {
                                valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                            };
                            list_eo_table = new List('eo_table', option_eo_table);
                            return;
                        }
                    } else {
                        messageCount_eo_analyzer++;
                        document.querySelector('#eo_analyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_eo_analyzer").value = messageCount_eo_analyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker6.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker6) {
                    worker6.terminate();
                }
                worker6 = null;
                document.getElementById("eo_analyzer").textContent = "Analyze";
                if (messageCount_eo_analyzer > 0) {
                    option_eo_table = {
                        valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                    };
                    list_eo_table = new List('eo_table', option_eo_table);
                }
                const error_message = "<br><a>AError: nalyzer terminated due to an error.</a><br>";
                document.getElementById('eo_table').innerHTML += error_message;
                return;
            }
        }

        function eo_solve(slot_option, rotation_option) {
            document.getElementById("solver").value = "EOCross";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('slot_eo').value = slot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['EOCross']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function add(s) {
            document.getElementById('scr').value += "\n" + s;
            save();
        }

        const details_analyzer = document.getElementById("analyze");
        const details_eo_analyzer = document.getElementById("eo_analyze");
        const details_panalyzer = document.getElementById("panalyze");
        const details_pair_analyzer = document.getElementById("pair_analyze");
        const details_pair_panalyzer = document.getElementById("pair_panalyze");
        const details_mask_options = document.getElementById("maskOptions");
        const details_preview = document.getElementById("details_preview");
        const details_advanced_settings = document.getElementById("advancedSettings");
        const details_cubeUI = document.getElementById("details_cubeUI");
        const summary_analyzer = document.getElementById("summary_analyzer");
        const summary_eo_analyzer = document.getElementById("summary_eo_analyzer");
        const summary_panalyzer = document.getElementById("summary_panalyzer");
        const summary_pair_analyzer = document.getElementById("summary_pair_analyzer");
        const summary_pair_panalyzer = document.getElementById("summary_pair_panalyzer");
        const summary_mask_options = document.getElementById("summaryMaskOptions");
        const summary_preview = document.getElementById("summary_preview");
        const summary_advanced_settings = document.getElementById("summaryAdvancedSettings");
        const summary_cubeUI = document.getElementById("summary_cubeUI");

        details_analyzer.addEventListener('toggle', () => {
            if (details_analyzer.open) {
                summary_analyzer.textContent = "Hide Analyzer";
            } else {
                summary_analyzer.textContent = "Show Analyzer";
            }
        });

        details_eo_analyzer.addEventListener('toggle', () => {
            if (details_eo_analyzer.open) {
                summary_eo_analyzer.textContent = "Hide Analyzer";
            } else {
                summary_eo_analyzer.textContent = "Show Analyzer";
            }
        });

        details_panalyzer.addEventListener('toggle', () => {
            if (details_panalyzer.open) {
                summary_panalyzer.textContent = "Hide Analyzer";
            } else {
                summary_panalyzer.textContent = "Show Analyzer";
            }
        });

        details_pair_analyzer.addEventListener('toggle', () => {
            if (details_pair_analyzer.open) {
                summary_pair_analyzer.textContent = "Hide Analyzer";
            } else {
                summary_pair_analyzer.textContent = "Show Analyzer";
            }
        });

        details_pair_panalyzer.addEventListener('toggle', () => {
            if (details_pair_panalyzer.open) {
                summary_pair_panalyzer.textContent = "Hide Analyzer";
            } else {
                summary_pair_panalyzer.textContent = "Show Analyzer";
            }
        });

        details_mask_options.addEventListener('toggle', () => {
            if (details_mask_options.open) {
                summary_mask_options.textContent = "Hide Stickering Settings";
            } else {
                summary_mask_options.textContent = "Show Stickering Settings";
            }
        });

        details_preview.addEventListener('toggle', () => {
            if (details_preview.open) {
                summary_preview.textContent = "Hide Preview";
            } else {
                summary_preview.textContent = "Show Preview";
            }
        });

        details_advanced_settings.addEventListener('toggle', () => {
            if (details_advanced_settings.open) {
                summary_advanced_settings.textContent = "Hide Advanced Settings";
            } else {
                summary_advanced_settings.textContent = "Show Advanced Settings";
            }
        });

        details_cubeUI.addEventListener('toggle', () => {
            if (details_cubeUI.open) {
                summary_cubeUI.textContent = "Hide Cube Editor";
            } else {
                summary_cubeUI.textContent = "Show Cube Editor";
            }
        });

        const selectsMaskOptions = details_mask_options.querySelectorAll('select');

        selectsMaskOptions.forEach(select => {
            select.addEventListener('change', (event) => {
                setMaskTmp();
            });
        });

        document.getElementById('CheckboxAutoMaskSetting').addEventListener('click', function () {
            AutoMaskSetting = document.getElementById('CheckboxAutoMaskSetting').checked;
        });

        const modalOverlay = document.getElementById('modal-overlay');
        const modalPanel = document.getElementById('modal-panel');
        const modalTextContent = document.getElementById('modal-text-content');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalCopyBtn = document.getElementById('modal-copy-btn');

        function showModalWithText(text) {
            modalTextContent.textContent = text;
            modalOverlay.classList.remove('hidden');
            document.body.classList.add('modal-open');
        }

        function hideModal() {
            modalOverlay.classList.add('hidden');
            document.body.classList.remove('modal-open');
        }

        function copyModalText() {
            const textToCopy = modalTextContent.textContent;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = textToCopy;
            tempTextArea.style.position = 'absolute';
            tempTextArea.style.left = '-9999px';
            document.body.appendChild(tempTextArea);

            tempTextArea.select();
            navigator.clipboard.writeText(textToCopy).then(() => {
                modalCopyBtn.textContent = 'Success!';
                setTimeout(() => { modalCopyBtn.textContent = 'Copy'; }, 2000);
            }).catch(() => {
                modalCopyBtn.textContent = 'Failed';
                setTimeout(() => { modalCopyBtn.textContent = 'Copy'; }, 2000);
            }).finally(() => {
                document.body.removeChild(tempTextArea);
            });
        }

        function showModalWithCustomText() {
            showModalWithText(body);
        }

        modalCopyBtn.addEventListener('click', copyModalText);
        modalCloseBtn.addEventListener('click', hideModal);
        modalOverlay.addEventListener('click', (event) => {
            if (event.target === modalOverlay) {
                hideModal();
            }
        });
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && !modalOverlay.classList.contains('hidden')) {
                hideModal();
            }
        });

        document.getElementById('clear').addEventListener('click', function () {
            document.getElementById('scr').value = '';
            save();
        });

        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const scrambleParam = urlParams.get(idToKeyMap['scr']);
            document.getElementById("result").innerHTML = "";
            if (scrambleParam) {
                const scr = decodeURIComponent(scrambleParam.replace(/_/g, ' ').replace(/-/g, '\''));
                document.getElementById('scr').value = scr;
                const sol_num = urlParams.get('index');
                const sol = urlParams.get('sol');
                if (sol_num && sol) {
                    messageCount = Number(sol_num) - 1;
                    const sol_fixed = sol.replace(/_/g, ' ').replace(/-/g, '\'');
                    sol_input = true;
                    appendSol(scr, sol_fixed);
                    sol_input = false;
                    document.getElementById("countLine").value = 1;
                } else {
                    document.getElementById("countLine").value = 0;
                }
            }
            document.getElementById('scr').value = scrambleParam ? decodeURIComponent(scrambleParam.replace(/_/g, ' ').replace(/-/g, '\'')) : '';
            if (scrambleParam === '') {
                document.getElementById("reverse").classList.add("hidden");
                document.getElementById("mirror").classList.add("hidden");
            }
            undoButton.classList.add("hidden_small");
            redoButton.classList.add("hidden_small");
            setParamsFromUrl(urlParams);
            save();
        };
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('Service Worker registered successfully:', registration);
                    })
                    .catch(err => {
                        console.log('Service Worker registration failed:', err);
                    });
            });
        }
    </script>
</body>

</html>